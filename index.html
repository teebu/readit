<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="apple-touch-icon" sizes="180x180" href="./images/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="./images/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="./images/favicon-16x16.png" />
    <link rel="manifest" href="./images/site.webmanifest" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <style>
      * {
        font-family: "Segoe UI", Arial, "sans-serif"; /* <-- fonts */
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #hello {
        height: 100%;
        width: 100%;
        padding: 6px;
        display: flex;
        flex-flow: column;
      }

      #text {
        flex: 1 1 auto;
        min-width: 15em;
        min-height: 1.4em;
        width: 100%;
        margin-top: 10px;
        margin-right: 10px;
        padding: 0.1em 0.1em 0 0.1em;
        background-color: white;
        font-size: 22px;
        text-align: left;
        border: 2px solid black;
        border-radius: 2px;
        overflow-y: auto;
        scroll-behavior: smooth;
      }

      @media only screen and (max-width: 480px) {
        #text {
          font-size: 32px;
          width: 100%;
          min-width: 8em;
          min-height: 2em;
        }
      }

      section {
        min-height: 100%;
      }

      .button {
        background-color: #4caf50; /* Green */
        border: none;
        width: 100px;
        height: 50px;
        color: white;
        padding: 8px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 20px;
        margin: 4px 2px;
        cursor: pointer;
        -webkit-transition-duration: 0.4s; /* Safari */
        transition-duration: 0.4s;
      }

      .button:disabled,
      .button[disabled] {
        border: #999999;
        background-color: #264c26;
        color: white;
      }

      @media only screen and (max-width: 480px) {
        .button {
          width: 140px;
          height: 75px;
          font-size: 32px;
        }
      }

      .btn {
        box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
      }

      .btn2:hover {
        box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.24), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
      }

      .slidecontainer {
        width: 100%;
      }

      .slider {
        -webkit-appearance: none;
        width: 100%;
        height: 25px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }

      .slider:hover {
        opacity: 1;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: #4caf50;
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 25px;
        height: 25px;
        background: #4caf50;
        cursor: pointer;
      }

      .dropdown {
        float: left;
        overflow: hidden;
      }

      .dropdown .dropbtn .canvyy {
        cursor: pointer;
        font-size: 16px;
        border: none;
        outline: none;
        color: white;
        padding: 14px 16px;
        background-color: inherit;
        font-family: Arial, Helvetica, sans-serif;
        margin: 0;
      }

      .dropdown:hover .dropbtn,
      .dropbtn:focus {
        background-color: #2f6b31; /* Green */
        border: none;
        width: 100px;
        height: 50px;
        color: white;
        padding: 8px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 20px;
        margin: 4px 2px;
        cursor: pointer;
        -webkit-transition-duration: 0.4s; /* Safari */
        transition-duration: 0.4s;
      }

      .dropbtn {
        background-color: #4caf50; /* Green */
        border: none;
        width: 100px;
        height: 50px;
        color: white;
        padding: 8px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 20px;
        margin: 4px 2px;
        cursor: pointer;
        -webkit-transition-duration: 0.4s; /* Safari */
        transition-duration: 0.4s;
      }

      .dropdown-content {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 160px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
        z-index: 1;
      }

      .dropdown-content a {
        float: none;
        color: black;
        padding: 12px 16px;
        text-decoration: none;
        display: block;
        text-align: left;
      }

      .dropdown-content a:hover {
        background-color: #ddd;
      }

      .show {
        display: block;
      }
    </style>
    <script>
      $(function () {
        document.querySelector("div[contenteditable]").addEventListener("paste", function (e) {
          e.preventDefault();
          var text = e.clipboardData.getData("text/plain");

          text = text.replace("\n", "@NewLine<div>");
          text = text.replace(/\n/g, "@NewLine</div><div>");

          text = text.replace(/ /g, " ");
          text = text.replace(/\n/g, "");
          text = text.replace(/@NewLine/g, "\n");
          //text = text.replace(/\r/g, "");

          //text = text.replace("<p>", "<BR>");
          //alert(text);

          document.execCommand("insertHTML", false, text);
        });
      });

      /////////////////////////// new code

      /*var scriptStr = function () {*/

      var debugging = false;
      var x;
      var spanx;
      var spanxLocations = [];
      var offsetbyregex = true;

      var beforelastoffset = 0;
      var lastoffset = 0;
      var offset = 2;
      var speechRate = 2;

      var canceled = true;

      var message = new SpeechSynthesisUtterance();
      var voices;

      // used when space has its own element and is skipped between overflow elements, might happen when microsoft voice reads dates
      var spaceBuffer = 0;

      var richCaretIndex = 0;
      var spanid = 0;

      var originalHtml = "";
      var originalOffset = 0;
      var doc;
      var substringLocation = 0;
      var whereDidweResume;
      var lastHilight = -1;

      var spanidOfAlldescendants;
      var alldescendantsToSpanid;

      var Mydialog;
      var currentVoice = 2;
      var voiceName = "Microsoft Aria";
      var NotOnboundary = false;

      //maximum chars for google voices, doesn't apply to microsoft edge.
      var isEdge = false;
      var _maximumChars = 250;

      var px;
      var py;

      var canClick = false;
      var loaded = false;
      var hasspeechCircle = false;

      var circlebottom = 10 + "px";
      var circleright = 10 + "px";
      var circleleft = null;
      var circletop = null;

      var ranAtLeastOnce = false;

      var readMultipleNodes = false;
      var mappingMultipleNodes = false;
      var spaceAlternative = "";
      var NullSpaceAlternative = ""; //"";
      var autoscroll = true;

      var startTimer;
      var startedReadingIndex;
      var originalTitle = "";

      //scrolling variables
      var tooBig = false;
      var scrollLocation = null;

      //Ultra Fast Variables

      var _curentTarget;
      var _brandNew = true;
      var _ultrafast = true;
      var _ultra_Xstr = "";
      var _ultra_descendants = [];
      var _ultra_index = 0;
      var _ultra_lastRect = null;

      var _mapping_xLength = false;
      var _ultra_xLength = 0;
      var _ultra_xLengthBuffer = 0;
      var _ultra_xLengthRead = 0;
      var _ultra_Loops = 0;

      // link list itteration variables for highligting text
      var lastCurrent;
      var lastCurrentIndex = 0;

      //highlight only yellow, but white text on dark backgorund ends up not being visible
      var yellowHighlightOnly = false;
      /*function unwrapThemAll(){

	var mySpans = $("span[id^='ttsh']");
	for( var i = 0; i < mySpans.length; i++){

		$(mySpans[i]).contents().unwrap()
	}
	
	mySpans = $("span[id^='ttsh']");
		for( var i = 0; i < mySpans.length; i++){
			mySpans[i].remove();
		}
  }*/
      var unified_emoji_ranges = ["[\ud800-\udbff]", "[\udc00-\udfff]"];
      var replaceDictionary = {
        "[\u0300-\u036f]": "",
        "[\u201C\u201D]": '"',
      };

      var eraseDictionary = {};

      /*{
  "*": " ",
  "Mr\\.": "Mister",
  "-": " ",
  "\\.\\.\\.": ".  ",
  "|": " ",
  Ã¸: "o",
  "~": " ",
  "<": " ",
  "[\u0300-\u036f]": "",
};*/

      function debugIt(debutStr, deskcriptoin = "N/A") {
        if (debugging) {
          console.log(deskcriptoin);
          console.log(debutStr);
        }
      }

      if (/Edg/.test(navigator.userAgent)) {
        //alert('Hello Microsoft Edge User!');
        _maximumChars = 400; //1500; //310;
        isEdge = true;
      }

      var totalReadStrLen = 0;
      var lastReadstr = "";
      var afiLastHighligt = -1;
      function adjustforinflation(indx) {
        try {
          if (afiLastHighligt != lastHilight && lastReadstr) {
            totalReadStrLen += lastReadstr.length;
            afiLastHighligt = lastHilight;
            lastReadstr = "";
          }

          let lh = spanxLocations[lastHilight];
          readMultipleNodes && (lh = nodesToWords[lh]);

          let readStr = trimmer(originalHtml.substring(0, indx - lh));
          lastReadstr = readStr;
          if (NotOnboundary) {
            lastReadstr = originalHtml;
          }
          //console.log( readStr + " TRS: " + totalReadStrLen + " UL: " + _ultra_xLength + " lR: " + lastReadstr + " LH:" + lastHilight);
          return readStr.length + totalReadStrLen;
        } catch (Ex) {
          return 0;
        }
      }

      function getEstimatedProgress() {
        try {
          var totalLength;
          var readingIndex;

          if (_ultrafast) {
            totalLength = _ultra_xLength;
            readingIndex = adjustforinflation(richCaretIndex) + _ultra_xLengthRead;
          } else {
            totalLength = x.length;
            readingIndex = richCaretIndex;
          }

          if (startedReadingIndex == -1) {
            startedReadingIndex = readingIndex;
          }

          if (originalTitle == "") {
            originalTitle = document.title;
          }

          var elapsedTime = Date.now() - startTimer;
          var readSofar = readingIndex - startedReadingIndex;
          var remaining = totalLength - readingIndex;

          var timeLeft = (elapsedTime / readSofar) * remaining;

          //console.log(  readingIndex + " " + totalLength + " " + _ultra_xLengthRead + " " + _ultra_xLengthBuffer + " " + (readingIndex / totalLength))
          //console.log( (readingIndex + " " +  totalLength));

          if (timeLeft >= 0 && timeLeft != Infinity) {
            var readProgress = msToTime(timeLeft) + " " + ((readingIndex / totalLength) * 100).toFixed(2) + "% ";
            outputEsimatedProgress(readProgress);
          }
        } catch (Ex) {}
      }

      function outputEsimatedProgress(readProgress) {
        if (originalTitle != "") {
          if (_ultrafast) {
            readProgress = readProgress + /*" U:" + _ultra_xLengthBuffer + " L:" + _ultra_Loops + */ " " + originalTitle;
          } else {
            readProgress = readProgress + originalTitle;
          }
          document.title = readProgress;
        }
      }

      function msToTime(ms) {
        let seconds = (ms / 1000).toFixed(1);
        let minutes = (ms / (1000 * 60)).toFixed(1);
        let hours = (ms / (1000 * 60 * 60)).toFixed(1);
        let days = (ms / (1000 * 60 * 60 * 24)).toFixed(1);
        if (seconds < 60) return seconds + " Sec";
        else if (minutes < 60) return minutes + " Min";
        else if (hours < 24) return hours + " Hrs";
        else return days + " Days";
      }

      function readText(resume) {
        if (x == null) {
          return;
        }

        canceled = false;

        //estimated progress timer
        startedReadingIndex = -1;
        startTimer = Date.now();

        if (speechSynthesis.paused && resume) {
          speechSynthesis.resume();
          return;
        }

        //var tarea = document.body;
        lastoffset = richCaretIndex;

        if (lastoffset == x.length) {
          lastoffset = 0;
          richCaretIndex = 0;
        }
        beforelastoffset = lastoffset;
        if (x.charAt(beforelastoffset) == "\n") {
          beforelastoffset++;
        }

        //offset = getIndex(x, lastoffset + 1);
        removeMultipleNodeHilights();

        if (lastoffset == undefined) {
          beforelastoffset = 0;
          lastoffset = 0;
        }

        if (getNextIndexThatIsNotEmpty() == false) {
          console.log("No words there..");
          pause();
          var button = document.getElementById("btn");
          button.disabled = false;
          return;
        }

        if (offset < 0) {
          offset = x.length;
        }

        speakMessage();
        highlight();
        outputEsimatedProgress("");
        sendMessageToBackground("reading");

        //startSlightFlicker();

        lastoffset = offset + 1;
        if (offsetbyregex == false) {
          lastoffset--;
        }
      }

      function startSlightFlicker() {
        if (yellowHighlightOnly && allSelectedNodes && allSelectedNodes.length > 0) {
          var oldStyle = [];
          for (i = 0; i < allSelectedNodes.length && i < 100; i++) {
            oldStyle.push(allSelectedNodes[i].style.boxShadow);
            allSelectedNodes[i].style.boxShadow = "0px 3px 8px rgba(174,203,250, 0.54)";
            allSelectedNodes[i].style.transition = "0.3s ease-in-out";
          }

          setTimeout(function () {
            for (i = 0; i < allSelectedNodes.length && i < 100; i++) {
              allSelectedNodes[i].style.boxShadow = oldStyle[i];
              allSelectedNodes[i].style.transition = "0.3s ease-in-out";
            }
          }, 600);
        }
      }

      function haswords() {
        /*removeing spaceAlternative from the string to skip empty replaced words or sentences*/
        var msgStr = x.substring(lastoffset, offset);
        regex = new RegExp(spaceAlternative, "g");
        msgStr = msgStr.replace(regex, "");

        regex = new RegExp(NullSpaceAlternative, "g");
        msgStr = msgStr.replace(regex, "");

        let currentDetectedLang = langDetector(msgStr);
        let currentVoice = voices[currentDetectedLang].name;

        msgStr = isItAWord(msgStr, currentVoice);

        return trimmer(msgStr).length > 0;
      }

      function isItAWord(msgStr, currentVoice) {
        // NOTE: some of these symbols aren't available in some of the non english languages
        var extras = "^@#$%^&*=";
        if (currentVoice.match(/english/gi) != null) {
          regex = new RegExp("[" + extras + "a-z0-9]", "gi");
          msgStr = msgStr.replace(regex, "");
        } else if (currentVoice.match(/ÑÑÑÑÐºÐ¸Ð¹|russian/gi) != null) {
          regex = new RegExp("[" + extras + "a-z0-9Ð°-Ñ]", "gi");
          msgStr = msgStr.replace(regex, "");
        } else {
          regex = new RegExp(
            /[^0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]+/,
            "g"
          );
          msgStr = msgStr.replace(regex, "");
        }

        return msgStr;
      }

      function speakMessage() {
        // make sure the bookmark only gets triggerd on page refresh.
        pressedOnBookmarkOrPlay = true;
        changeSpeechCircleColor();

        //ignoring the \n at the start of a new msg so it doesn't offset highlighting by one.
        var addOne = 0;
        if (x.charAt(lastoffset + addOne) == "\n" && beforelastoffset != 0) {
          addOne++;
        }

        var msgStr = x.substring(lastoffset + addOne, offset);
        //console.log(msgStr);
        //console.log(lastoffset + " " + beforelastoffset);
        try {
          /*msgStr = msgStr.replace(/[<]/g,'less than');*/
          msgStr = msgStr.replace(/[\u2018\u2019]/g, "'");

          if (readMultipleNodes) {
            regex = new RegExp(spaceAlternative, "g");
            msgStr = msgStr.replace(regex, " ");

            lastnullOtterance_iLocation = 0;
            lastnullOtterance_offset = 0;
            lastCharIndexOfNU = 0;
            rightOffset = 0;
            nullOtterance = msgStr;
            lastIndexOfNU = 0;
            regex = new RegExp(NullSpaceAlternative, "g");
            msgStr = msgStr.replace(regex, "");

            regex = new RegExp(/\n/, "gm");
            msgStr = msgStr.replace(regex, " ");

            /*if (_ultrafast) {
        //hopefully won't screw up the formatting because this is 'always' at the end of a current highlited element
        msgStr = msgStr.replace(/(?<![\.\?\!])\n/gm, ".\n\n\t\n");
        ultraFastOtterance = msgStr;
      }*/
          }
        } catch (Ex) {
          console.log(Ex);
        }

        /*var message = new SpeechSynthesisUtterance();*/

        message.text = msgStr;

        message.volume = 1;

        var slider = document.getElementById("speed");
        speechRate = slider.value / 100;

        message.rate = speechRate;
        message.pitch = 1;

        let currentDetectedLang = langDetector(msgStr);

        var selectedVoice = voices[currentDetectedLang];
        message.voice = voices[currentDetectedLang];
        message.voiceURI = selectedVoice.voiceURI;
        message.lang = selectedVoice.lang;

        /*console.log(
    currentVoice + "\n" + selectedVoice.voiceURI + "\n" + selectedVoice.lang
  );*/

        console.log("READING:");
        console.log(msgStr);
        try {
          /*
    var voiceName = voices[currentDetectedLang].name;
    var lang = selectedVoice.lang;
    var rate = speechRate;
    var DELIM = '\n\n|\n\n';
    var speakThis = voiceName + DELIM + lang +DELIM + rate + DELIM + msgStr;
    chrome.runtime.sendMessage({ toSay: speakThis });
    */

          //delayedSpeak();
          !isEdge && speechSynthesis.speak(message);
          isEdge && speechSynthesis.speak(message);
        } catch (Ex) {
          console.log(Ex);
        }
        //console.log(":::speaking:::");
      }

      function delayedSpeak() {
        var i = 0;
        var lastLocation = -1;
        var scrolInterval = setInterval(function () {
          i++;
          //console.log( i );
          //console.log( lastLocation + " " + window.pageYOffset + " | " + scrollable() + " " + window.pageYOffset + " " + scrollLocation + " " + document.hidden);

          if (!scrollable() || lastLocation == window.pageYOffset || i > 10 || Math.abs(parseInt(window.pageYOffset) - parseInt(scrollLocation)) <= 1) {
            clearInterval(scrolInterval);
            if (canceled == false) {
              setTimeout(function () {
                !isEdge && speechSynthesis.speak(message);
                isEdge && speechSynthesis.speak(message);
                scrollLocation = null;
              }, 50);
            }
          } else {
            lastLocation = window.pageYOffset;
            return;
          }
        }, 100);
      }

      //check to see if the page can be scrolled and if the scroll location is valid
      function scrollable() {
        if (document.hidden || scrollLocation == null || scrollLocation < 0 || window.innerHeight + window.scrollY >= document.body.scrollHeight) {
          //console.log( scrollLocation + " | " + window.innerHeight + " " +  window.scrollY + " " + document.body.scrollHeight );
          return false;
        }
        //console.log( "scrollable: True " );
        return true;
      }

      function delayedScroll(y) {
        scrollLocation = y;
        if (scrollable && !(Math.abs(parseInt(window.pageYOffset) - parseInt(scrollLocation)) <= 1)) {
          //console.log( "scrolling");
          window.scrollTo({ top: y, behavior: "smooth" });
        }
        /*setTimeout(function () {
    window.scrollTo({ top: y, behavior: "smooth" })
  }, 500);*/
      }

      function langDetector(msgStr) {
        currentVoice = selectVoice(voiceName, 0);
        var currentDetectedLang = detectLanguage(msgStr);
        if (currentDetectedLang == null || currentDetectedLang < 0) {
          currentDetectedLang = 0;
        }
        return currentDetectedLang;
      }

      var autoDetected = -1;
      function detectLanguage(msgStr) {
        //cyrilic alphabet only, if it contains english use currentVoice

        // add this back if you want to ignore mixed strings and default to a-z
        /*&& (  autoDetected >= 0 || msgStr.match(/[a-z]+/ig) == null  )*/

        if (msgStr.match(/[Ð°-Ñ]+/gi) != null && msgStr.match(/[a-z]+/gi) == null) {
          var sv = selectVoice(/ÑÑÑÑÐºÐ¸Ð¹|russian/gi, currentVoice);
          autoDetected = sv;
          return sv;
        }

        if (autoDetected >= 0) {
          //if we auto detected a language and it's now reading stand alone numbers or symbols
          // we keep going in that language
          if (msgStr.match(/[a-z]+/gi) == null) {
            return autoDetected;
          }
        }

        autoDetected = -1;
        return currentVoice;
      }

      function selectVoice(strMatch, current) {
        var i;
        for (i = 0; i < voices.length; i++) {
          if (voices[i].name == strMatch) {
            return i;
          }
        }
        //if no match found
        return current;
      }

      function unHilight() {
        if (lastDoc != null) {
          lastDoc.removeAttribute("style");
          setInheritColor(lastDoc);
        }
        whereDidweResume = -1;
      }

      function clickorendHighlightReset() {
        try {
          if (doc != null) {
            removeMyHighlight();
          }

          if (nodesToWords) {
            removeMultipleNodeHilights();
          }

          if (lastDoc != null) {
            lastDoc.removeAttribute("style");
            setInheritColor(lastDoc);
          }

          lastHilight = -1;

          originalHtml = "";
          originalOffset = 0;
          doc = null;
        } catch (E) {
          console.log(E);
        }
      }

      function removeMultipleNodeHilights() {
        for (var j = 0; j < allSelectedNodes.length; j++) {
          var tmpDoc = allSelectedNodes[j];
          if (tmpDoc) {
            tmpDoc.removeAttribute("style");
            setInheritColor(tmpDoc);
            if (tmpDoc.firstChild != null) {
              try {
                if (myHilightSpan != null) {
                  highlightRemoved = true;
                  myHilightSpan.remove();
                  myHilightSpan = null;
                  docsFirstChild.nodeValue = childsNodeValue;
                  removeOverflowElments();
                }
                tmpDoc.parentNode.insertBefore(tmpDoc.firstChild, tmpDoc);
              } catch (ex) {
                //console.log(ex);
              }
            }
            if (tmpDoc) {
              tmpDoc.remove();
              tmpDoc = null;
            }
          }
        }
        lastHilight = -1;
        allSelectedNodes = [];
      }

      function isDelimiterOrSpace(letter) {
        if (letter == "." || letter == "!" || letter == "?" || letter == " ") {
          return true;
        }
        return false;
      }

      function findNewLine() {
        //find new line [\n]

        let position = 0;
        var ff = 0;
        if (!NotOnboundary) {
          //console.log( "char at:" +  x.charAt(lastoffset-1) + x.charAt(lastoffset) +  x.charAt(lastoffset+1) );

          if (x.charAt(lastoffset) == "\n") {
            lastoffset++;
          }

          for (i = 0; i < spanxLocations.length; i++) {
            position = nodesToWords[spanxLocations[i]];
            if (position - 1 >= lastoffset || lastoffset == 0) {
              break;
            }
            if (position && (x.charAt(position - 1) == "\n" || x.charAt(position) == "\n")) {
              if (x.charAt(position - 1) == "\n") {
                ff = position;
              } else {
                ff = position + 1;
              }
            }
          }
        } else {
          ff = lastoffset;
        }
        return ff;
      }

      var lastPos;
      var zerothDescendant;
      function setLastHighlightPosition(p) {
        lastPos = p;
        zerothDescendant = alldescendants[0];
        //console.log( lastPos + " setLastHighlightPosition " + offset );
      }

      function needsHighlighting() {
        //console.log( lastPos + " needsHighlighting " + offset );
        //console.log( offset > lastPos );
        //console.log( zerothDescendant !== alldescendants[0] );

        return offset > lastPos || zerothDescendant !== alldescendants[0];
      }

      var allSelectedNodes = [];
      var bussyHilighting = false;
      function highlight(scroll = autoscroll) {
        var set = false;
        var i = 0;
        scrollLocation = null;

        if (readMultipleNodes && nodesToWords) {
          //if( wordsToNodes[lastoffset] < 0){
          // return;
          //}

          bussyHilighting = true;
          removeMultipleNodeHilights();

          var partXAdd = 0;
          try {
            var partX = x.substring(offset, offset + 100);
            var partXAdd = partX.match(/[^-\s]/).index;
            if (partXAdd == 0 && lastoffset - offset > 1) {
              partXAdd = 1;
            } else if (isDelimiterOrSpace(x.charAt(offset - 2)) && x.charAt(offset - 1) == "\n") {
              partXAdd = 1;
            }
          } catch (ex) {}

          //console.log( "ZZZ" + x.substring( offset-10, offset +10 ));
          //console.log(wordsToNodes[nodesToWords[offset]] + " " + offset + "L:" + wordsToNodes.length );
          //console.log( "QQQQ" );

          //find new line [\n]
          /*var ff = lastoffset;
    if (!NotOnboundary) {
      for (; ff >= 0; ff--) {
        if (x.charAt(ff) == "\n") {
          ff++;
          break;
        }
      }
    }
    if( isNaN(ff) ){
      ff = lastoffset;
    }*/

          let ff = findNewLine();
          for (i = 0; i < spanxLocations.length - 1; i++) {
            //console.log( spanxLocations[i + 1] + " " + wordsToNodes[ff] + " ff " + ff );
            if (spanxLocations[i + 1] <= wordsToNodes[ff]) {
            } else {
              //console.log( nodesToWords[spanxLocations[i+1]] + ' OO ' + lastoffset );
              mappingMultipleNodes = true;
              var id = spanidOfAlldescendants[i];
              if (
                id >= 0 &&
                alldescendants[id] &&
                ((trimmer(alldescendants[id].nodeValue).length > 0 && alldescendants[id].nodeValue.trim().length > 0) ||
                  (alldescendants[id].nodeValue.length == 1 && alldescendants[id].nodeValue == " "))
                // added this " " lenght 1 part for elements that contain a span with only a single space
                /*|| (alldescendants[id].nodeValue.length == 1 && alldescendants[id].nodeValue.replace(/\s+/, "") == "")/*|| alldescendants[id].nodeValue == " "*/
              ) {
                lastDoc = createSpan(i); //needs to be global for addDialogToNode to work without highlight.

                wrap(alldescendants[id], lastDoc);
                if (!NotOnboundary && lastDoc && lastDoc.style) {
                  //if (!_ultrafast || allSelectedNodes.length == 0) {
                  //lastDoc.style.backgroundColor = "#AECBFA";
                  //lastDoc.style.color = "black";
                  //}
                }

                allSelectedNodes.push(lastDoc);
              }

              mappingMultipleNodes = false;

              //fix for out of bounds by 1 offset at end of file.
              var tmpOffset = offset;
              if (wordsToNodes[offset] == null) {
                tmpOffset--;
              }

              setLastHighlightPosition(nodesToWords[spanxLocations[i + 1]]);

              // in case the next line is a just a space with no text, and this is the last element scanned.
              if (nodesToWords[spanxLocations[i + 1]] == x.length - 1) {
                setLastHighlightPosition(nodesToWords[spanxLocations[i + 1]] + 2);
                set = false;
                break;
              }
              if (nodesToWords[spanxLocations[i + 1]] >= tmpOffset) {
                /*console.log( partXAdd );*/
                //console.log( spanxLocations[i] + " " + wordsToNodes[offset] );
                //console.log( "ZZZ" + x.substring( offset, offset +50 ));
                //console.log( "ZZZ");
                if (NotOnboundary) {
                  set = false;
                  break;
                }
                let position = nodesToWords[spanxLocations[i + 1]];
                if (i + 1 == spanxLocations.length || (position && (x.charAt(position - 1) == "\n" || x.charAt(position) == "\n"))) {
                  set = false;

                  break;
                }
              }
            }
          }

          var otterrance = replaceGlobally(x.substring(beforelastoffset, offset), NullSpaceAlternative, "");
          var tmpOffset = 0;
          if (otterrance.charAt(0) == "\n" || otterrance.charAt(0) == " ") {
            tmpOffset++;
          }
          var j = whatIsTheCurrentNode(tmpOffset) + 1;
          if (NotOnboundary) {
            for (; j > 0 && j < allSelectedNodes.length; j++) {
              styleNodes(allSelectedNodes[j]);
            }
            if (lastDoc != null) {
              //otterrance = replaceGlobally( otterrance, "\n", "" );
              //console.log( "|" + otterrance + "| " + otterrance.length );
              yellowHighlight("yellow", 0, otterrance.trimEnd().length, lastDoc);
            }
          }

          if (/*!_ultrafast &&*/ allSelectedNodes && allSelectedNodes[0]) {
            const myRect = allSelectedNodes[0].getBoundingClientRect();
            const totalHeight = calculateTotalHeight(allSelectedNodes);
            const y = myRect.top + window.pageYOffset - window.innerHeight / 2 + totalHeight / 2;

            tooBig = totalHeight > window.innerHeight;
            tooBig = true;

            if (totalHeight != 0 && !inIframe()) {
              if (lastDoc != null && hasWhiteSpaceStyle(lastDoc.firstChild) && lastDoc.firstChild.nodeValue.match(/\n/g)) {
                //debugIt( otterrance, "otterrance" );
                //yellowHighlight("#AECBFA", 0, otterrance.trimEnd().length);
                yellowHighlight("#yellow", 0, otterrance.trimEnd().length, lastDoc);
              } else {
                highlightSelectedNodes();
                //scroll && !tooBig && window.scrollTo({ top: y, behavior: "smooth" });
                scroll && !tooBig && delayedScroll(y);
              }
            } else {
              highlightSelectedNodes();
              //yellowHighlight("#AECBFA", 0, otterrance.trimEnd().length);
              /*highlightSelectedNodes();
        var sortOfCenter = Math.round((allSelectedNodes.length - 1) / 2);
        if (allSelectedNodes[sortOfCenter]) {
          allSelectedNodes[sortOfCenter].scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }*/
            }
          }

          bussyHilighting = false;

          /*for (i = 0; i < spanxLocations.length; i++) {
      if (spanxLocations[i] >= wordsToNodes[lastoffset]) {
        if (i > 0 && spanxLocations[i] + 1 > wordsToNodes[offset]) {
          i--;
        }
        if (
          i + 1 < spanxLocations.length &&
          wordsToNodes[offset] > spanxLocations[i + 1] + 1
        ) {
          i++;
        }
        set = false;
        break;
      }
    }*/
        } else {
          for (i = 0; i < spanxLocations.length; i++) {
            if (spanxLocations[i] >= lastoffset) {
              if (i > 0 && spanxLocations[i] + 1 > offset) {
                i--;
              }
              if (i + 1 < spanxLocations.length && offset > spanxLocations[i + 1] + 1) {
                i++;
              }
              set = true;
              break;
            }
          }
        }
        if (set) {
          if (lastDoc != null) {
            lastDoc.removeAttribute("style");
            setInheritColor(lastDoc);
            doc = lastDoc;
            removeMyHighlight();
          }

          /*++++ */
          var id = spanidOfAlldescendants[i];
          if (id >= 0 && alldescendants[id] && trimmer(alldescendants[id].nodeValue).length > 0) {
            lastDoc = createSpan(i);
            wrap(alldescendants[id], lastDoc);
          }

          /*---- */

          if (lastDoc != null) {
            if (!NotOnboundary && lastDoc && lastDoc.style) {
              styleNodes(lastDoc);
            }

            if (scroll) lastDoc.scrollIntoView({ behavior: "smooth", block: "center" });
          }

          lastHilight = i;

          if (NotOnboundary && lastDoc != null) {
            /*lastDoc.removeAttribute("style");
        lastDoc.style.color = "inherit";*/

            var otterrance = replaceGlobally(x.substring(beforelastoffset, offset), NullSpaceAlternative, "");
            //otterrance = replaceGlobally( otterrance, "\n", "" );
            yellowHighlight("#AECBFA", 0, otterrance.trimEnd().length, lastDoc);
          }
        }
      }

      function highlightSelectedNodes() {
        for (i = 0; i < alldescendants.length; i++) {
          if (!NotOnboundary && allSelectedNodes[i] && allSelectedNodes[i].style) {
            styleNodes(allSelectedNodes[i]);
          }
        }
      }

      function styleNodes(selectedNode) {
        if (!yellowHighlightOnly) {
          //selectedNode.style.backgroundColor = "#AECBFA";
          //selectedNode.style.color = "black";
        }
      }

      function styleNodesString() {
        if (!yellowHighlightOnly) {
          return "<customreadxspanbefore style='background-color:#AECBFA !important; color:black !important;'>";
        }
        return "<customreadxspanbefore>";
      }

      function styleNodesStringAfter(otterranceColor, local_lastDoc) {
        if (!yellowHighlightOnly) {
          return "' style='background-color:" + otterranceColor + " !important" + "; color:black !important;'";
        }

        var color = window.getComputedStyle(local_lastDoc).getPropertyValue("color");
        color = splitRGB(color);
        if (isColorBright(color)) {
          otterranceColor = "green";
        }
        return "' style='background-color:" + otterranceColor + " !important'";
      }

      function splitRGB(rgb) {
        rgb = rgb
          .substring(4, rgb.length - 1)
          .replace(/ /g, "")
          .split(",");

        return rgb;
      }

      function isColorBright(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];

        hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));

        //console.log( hsp );
        if (hsp > 200) {
          return true;
        }
        return false;
      }

      function calculateTotalHeight(items) {
        try {
          let rectA = allSelectedNodes[0].getBoundingClientRect();
          let rectB = allSelectedNodes[items.length - 1].getBoundingClientRect();
          //if both are the same rect
          if (rectA.top == rectB.top) {
            return Math.max(rectA.height, rectB.height);
          }
          return rectB.top - rectA.top + rectB.height;
        } catch (ex) {
          //console.log(ex);
        }
      }

      function getNextIndexThatIsNotEmpty() {
        var i = 0;
        let hw = false;
        do {
          offset = getIndex(x, lastoffset + 1);
          i++;

          if ((hw = haswords()) == false) {
            lastoffset = offset;
            beforelastoffset = lastoffset;
            if (x.charAt(beforelastoffset) == "\n") {
              beforelastoffset++;
            }
          }
          //console.log("no words there |" + x.length + "| " + offset + " " + lastoffset);
          if (lastoffset == offset && offset > x.length) {
            return false;
          }
        } while (hw == false && (hw = haswords()) == false && i < 200);

        return hw;
      }

      message.onend = function (event) {
        myOnEnd(event);
      };

      function myOnEnd(event) {
        if (canceled == true) {
          return;
        }

        var moreElements = true;

        if (_ultrafast && lastoffset >= x.length) {
          lastoffset = 0;
          beforelastoffset = 0;
          richCaretIndex = 0;
          moreElements = areThereMoreElements();
          mapIndexForHighlight();
        }

        if ((lastoffset < x.length && !_ultrafast) || (_ultrafast && moreElements)) {
          beforelastoffset = lastoffset;
          if (x.charAt(beforelastoffset) == "\n") {
            beforelastoffset++;
          }

          if (getNextIndexThatIsNotEmpty() == false) {
            if (_ultrafast) {
              lastoffset = 0;
              beforelastoffset = 0;
              richCaretIndex = 0;
              mapIndexForHighlight();
              if (getNextIndexThatIsNotEmpty() == false) {
                console.log("No _ultrafast words there.");
                clickorendHighlightReset();
                togglePlayButton();
                saveBookmarkToStorage(window.location.href, "");

                var button = document.getElementById("btn");
                button.disabled = false;
                return;
              }
            } else {
              canceled = true;
              sendMessageToBackground("paused");
              console.log("No words there.");

              var button = document.getElementById("btn");
              button.disabled = false;
              return;
            }
          }

          if (offset < 0) {
            offset = x.length;
          }

          speakMessage();
          //check if elements are already highlighted
          if (needsHighlighting() || !isEdge) {
            highlight();
          } else {
            oldBoundIndex = -5;
          }
          getEstimatedProgress();
          sendMessageToBackground("reading");

          richCaretIndex = lastoffset;
          lastoffset = offset + 1;
          if (offsetbyregex == false) {
            lastoffset--;
          }
        } else {
          canceled = true;
          outputEsimatedProgress("0.0 Sec 100% ");
          clickorendHighlightReset();
          sendMessageToBackground("paused");
          saveBookmarkToStorage(window.location.href, "");

          var button = document.getElementById("btn");
          button.disabled = false;
        }
      }

      var highlightRemoved = true;
      function removeMyHighlight() {
        highlightRemoved = true;

        try {
          /*console.log("last highlight");*/
          if (myHilightSpan != null) {
            myHilightSpan.remove();
            myHilightSpan = null;
            docsFirstChild.nodeValue = childsNodeValue;
            removeOverflowElments();
            if (doc != null && doc.parentNode != null) {
              doc.parentNode.insertBefore(docsFirstChild, doc);
              doc.remove();
            }
          } else {
            if (doc != null && doc.parentNode != null) {
              if (doc.firstChild != null) {
                doc.parentNode.insertBefore(doc.firstChild, doc);
              }
              doc.remove();
              doc = null;
            }
          }
        } catch (ex) {
          console.log(ex);
        }
      }

      var myHilightSpan;
      var childsNodeValue;
      var docsFirstChild;
      var lastDoc;
      var oldBoundIndex;
      var MylinkedList;

      var nullOtterance = "";
      var lastIndexOfNU = 0;
      var lastCharIndexOfNU = 0;
      var ultraFastOtterance = "";

      var rightOffset = 0;

      message.onboundary = function (event) {
        if (event.name == "word") {
          myOnBoundary(event);
        }
      };

      function myOnBoundary(event) {
        //var otterrance = event.utterance.text;

        var ev_CharIndex = event.charIndex;
        var ev_CharLength = event.charLength;

        if (readMultipleNodes) {
          /*if (_ultrafast && ev_CharIndex > 0) {
      var tmpstr = ultraFastOtterance.substring(0, ev_CharIndex);
      ev_CharIndex -= (tmpstr.split(".\n\n\t\n").length - 1) * 4;
    }*/

          //adjust the ev_CharIndex by 1 for each null space in the string because they get replaced with "" on otterrance
          //var i = lastnullOtterance_iLocation;

          //if (1 == 2) {
          var i = lastIndexOfNU;
          //if( i < ev_CharIndex ){
          for (; i <= ev_CharIndex + rightOffset; i++) {
            if (nullOtterance && nullOtterance.charAt(i) == NullSpaceAlternative /*|| nullOtterance.charAt(i) == "\n"*/) {
              lastCharIndexOfNU++;
              rightOffset++;
            }
          }
          lastIndexOfNU = i;
          ev_CharIndex += lastCharIndexOfNU;
          //}
          //}
          //console.log( lastCharIndexOfNU + " " + lastIndexOfNU + " " +  ev_CharIndex );

          //One thing that surprised him was that while he had focused on marking the wall, the patrols had once more moved too closely for comfort.
          // ne thing that surprised him was that while he had fcused n marking the wall, the patrls had nce mre mved t clsely fr cmfrt.

          /*for (var i = 0; i < ev_CharIndex; i++) {
      if (nullOtterance.charAt(i) == NullSpaceAlternative) {
        ev_CharIndex++;
      }
    }*/

          if (bussyHilighting == false) {
            removeOverflowElments();

            whatIsTheCurrentNode(ev_CharIndex);

            yellowHighlight("yellow", ev_CharIndex, ev_CharLength, lastDoc);
          }
        } else {
          yellowHighlight("yellow", ev_CharIndex, ev_CharLength, lastDoc);
        }

        getEstimatedProgress();
      }

      var benchmarkTimer = null;
      var benchmarkIndex = 0;
      function benchmark(reset = false, name = "") {
        if (reset) {
          benchmarkTimer = null;
          benchmarkIndex = 0;
        }
        if (benchmarkTimer == null) {
          benchmarkTimer = Date.now();
        }
        console.log(name + " " + benchmarkIndex + ": " + (Date.now() - benchmarkTimer));
        benchmarkIndex++;
      }

      var overflowElements = [];

      function removeOverflowElments() {
        for (i = 0; overflowElements && i < overflowElements.length; i++) {
          var values = overflowElements[i];
          values.myHilightSpan.remove();
          values.myHilightSpan = null;
          values.docsFirstChild.nodeValue = values.childsNodeValue;
        }
        overflowElements = [];
      }

      function whatIsTheCurrentNode(ev_CharIndex, outOfBounds = false) {
        var i = 0;
        var set;
        var j = 0;

        for (; i < spanxLocations.length - 1; i++) {
          if ((nodesToWords[spanxLocations[i + 1]] == null && i + 2 == spanxLocations.length) || nodesToWords[spanxLocations[i + 1]] > beforelastoffset + ev_CharIndex) {
            set = true;
            break;
          }
        }

        // checks to make sure we didn't overshoot the last element
        while (nodesToWords[spanxLocations[i]] == -1 && i > 0) {
          i -= 1;
        }

        if (lastHilight != -1 && lastHilight != i) {
          if (lastDoc && lastDoc.firstChild != null) {
            try {
              if (myHilightSpan != null) {
                highlightRemoved = true;
                if (outOfBounds) {
                  overflowElements.push({ myHilightSpan: myHilightSpan, docsFirstChild: docsFirstChild, childsNodeValue: childsNodeValue });
                } else {
                  removeOverflowElments();
                  myHilightSpan.remove();
                  myHilightSpan = null;
                  docsFirstChild.nodeValue = childsNodeValue;
                }
              }
              /*lastDoc.parentNode.insertBefore(lastDoc.firstChild, lastDoc);*/
            } catch (ex) {
              console.log(ex);
            }
          }
          if (lastDoc) {
            /*lastDoc.remove();
      lastDoc = null;*/
          }
        }

        if (set) {
          var id = spanidOfAlldescendants[i];

          for (; j < allSelectedNodes.length && lastHilight != i; j++) {
            if (allSelectedNodes[j] && allSelectedNodes[j].firstChild === alldescendants[id]) {
              lastDoc = allSelectedNodes[j];
              break;
            } else {
              /*clears the hilight from preceding elements that have already been read
            could in theory make them highlight color instead once the onboundary is done with them
            before the reader moves to the next otterance.
          */
              // if (allSelectedNodes[j] != null) {
              //   if (1 == 1 || !_ultrafast) {
              //     allSelectedNodes[j].style.backgroundColor = "#AECBFA";
              //     allSelectedNodes[j].style.color = "black";
              //   } else {
              //     allSelectedNodes[j].removeAttribute("style");
              //     allSelectedNodes[j].style.color = "inherit";
              //     allSelectedNodes[j] = null;
              //   }
              // }
            }
          }

          //overflow element was not found so we set J to 0
          if (!allSelectedNodes[j]) {
            j = 0;
          }

          //used to highlight the current element that's being read, and centering it on screen.
          if (lastDoc && _ultrafast && lastHilight != i) {
            //lastDoc.style.backgroundColor = "#AECBFA";
            //lastDoc.style.color = "black";
            //lastDoc.scrollIntoView({ behavior: "smooth", block: "center" });
          }

          lastHilight = i;
          //console.log("LH:" + lastHilight);
          //console.log("J:" + j);

          return j;
        }
        return -1;
      }

      function printString(str, loopStart, loopLength) {
        var tmpStr = "";
        for (var i = loopStart; i < loopLength + loopStart && i < str.length; i++) {
          tmpStr += str.charAt(i);
        }
        return tmpStr;
      }

      function initHighlightSpan(local_lastDoc) {
        if (lastHilight >= 0 && local_lastDoc != null) {
          if (highlightRemoved == true) {
            highlightRemoved = false;
            /*removeMyHighlight();*/
            doc = local_lastDoc; /*document.getElementById("ttsh" + lastHilight );*/

            if (doc == null || doc.firstChild == null) {
              return;
            }
            /*good stuf */
            childsNodeValue = doc.firstChild.nodeValue;
            docsFirstChild = doc.firstChild;

            myHilightSpan = partialNode(doc.firstChild, "", "myHighlight" + lastHilight, doc.firstChild);

            if (myHilightSpan != null) {
              if (inIframe() && speechCircle && speechCircle.style) {
                speechCircle.style.transition = "all .5s ease-in-out";
                const rect = myHilightSpan.getBoundingClientRect();
                circletop = rect.top + "px";
                speechCircle.style.top = circletop;
              }
            }

            /* end of good stuf*/
            originalHtml = childsNodeValue;
            if (MylinkedList != null) {
              MylinkedList = null;
            }
            MylinkedList = MapForReplace(originalHtml);
            lastCurrent = null;
            lastCurrentIndex = 0;

            whereDidweResume = -1;
            substringLocation = 0;
            oldBoundIndex = -5;
          }
        }
      }

      function computeCharIndexAndLength(ev_CharIndex, ev_CharLength) {
        oldBoundIndex = ev_CharIndex;

        if (whereDidweResume < 0) {
          whereDidweResume = beforelastoffset - spanxLocations[lastHilight];
          if (whereDidweResume < 0) {
            whereDidweResume = 0;
          }
          substringLocation = whereDidweResume;
        }

        tmpCharIndex = ev_CharIndex + substringLocation;
        richCaretIndex = spanxLocations[lastHilight] + tmpCharIndex;

        if (readMultipleNodes && nodesToWords) {
          if (nodesToWords[spanxLocations[lastHilight]] == -1) {
            lastHilight = lastHilight - 1;
          }
          tmpCharIndex = ev_CharIndex + beforelastoffset - nodesToWords[spanxLocations[lastHilight]];
          //console.log(tmpCharIndex + " ::" + ev_CharIndex + " " + beforelastoffset + " " +  nodesToWords[spanxLocations[lastHilight]]);
          //console.log( doc );
          richCaretIndex = nodesToWords[spanxLocations[lastHilight]] + tmpCharIndex + spaceBuffer;
        }

        try {
          var current = MylinkedList;
          if (lastCurrent != null && !NotOnboundary) {
            current = lastCurrent;
          } else {
            lastCurrentIndex = 0;
          }

          for (var i = lastCurrentIndex; current.next != null && i < tmpCharIndex; i++) {
            current = current.next;
            lastCurrentIndex = i + 1;
            lastCurrent = current;
          }

          //if the first character is a spaceAlternative we ignore it, because the original didn't have that char.
          if (current.data == spaceAlternative) {
            current = current.next;
          }
          tmpCharIndex = current.next.realIndex;

          let tmpOverflow = -1;
          let realCharLength = 0;
          for (var i = 0; i < ev_CharLength && i < MylinkedList.size; i++) {
            if (current.next == null) {
              tmpOverflow = ev_CharLength - i;
              break;
            }
            current = current.next;
            if (current.data == NullSpaceAlternative /*&& i+1 != ev_CharLength*/ /*|| current.data == "\n"*/) {
              i = i - 1;
            }
            realCharLength++;
          }

          if (tmpOverflow == -1 && ev_CharLength > MylinkedList.size) {
            tmpOverflow = ev_CharLength - MylinkedList.size;
          }

          /*if it's a single char replace*/
          if (current.lastIndex) {
            ev_CharLength = current.lastIndex - tmpCharIndex + 1;
          } else {
            ev_CharLength = current.realIndex - tmpCharIndex + 1;
          }

          //check if the last character is a letter and not a word boundary
          //not sure why I was doing this, commenting out for now.
          let letter = isItAWord(current.data, message.voice.name);
          if (ev_CharLength > 1 && letter.length == 0 && current.data != NullSpaceAlternative) {
            //ev_CharLength--;
          }

          return { ev_CharLength: ev_CharLength, tmpCharIndex: tmpCharIndex, tmpOverflow: tmpOverflow, realCharLength: realCharLength };
        } catch (Ex) {
          /* uncomment it later if you need to debug this*/
          //console.log(Ex);
        }
      }

      function yellowHighlight(otterranceColor, ev_CharIndex, ev_CharLength, local_lastDoc, fromOverflow = 0) {
        initHighlightSpan(local_lastDoc);
        if (myHilightSpan == null) {
          highlightRemoved = true; /*in case of emergency, reset. Â¯\_(ã)_/Â¯  */
          return;
        }

        if (ev_CharLength > 0) {
          if (ev_CharIndex != oldBoundIndex || oldBoundIndex == 0) {
            /*console.log( ev_CharLength );*/

            let tmpOverflow = 0;
            tmpCharIndex = ev_CharIndex;
            realCharLength = ev_CharLength;
            let results = computeCharIndexAndLength(ev_CharIndex, ev_CharLength);
            if (results) {
              tmpCharIndex = results.tmpCharIndex;
              ev_CharLength = results.ev_CharLength;
              tmpOverflow = results.tmpOverflow;
              realCharLength = results.realCharLength;
            }

            var spanBefore = "<customreadxspanbefore>";
            var spanBeforeEnd = "</customreadxspanbefore>";

            try {
              //added recent to test new stuff

              let start = 0;
              let end = originalHtml.length;
              let hasWhiteSpace = false;
              //check if there are multiple new lines and add code accordingly. might need to deal with how we scroll to center
              if (hasWhiteSpaceStyle(docsFirstChild) && childsNodeValue.match(/\n/g)) {
                //debugIt(originalHtml, "originalHtml");
                hasWhiteSpace = true;
                local_lastDoc.removeAttribute("style");
                setInheritColor(local_lastDoc);
                spanBefore = styleNodesString();

                start = originalHtml.substring(0, tmpCharIndex).lastIndexOf("\n") + 1;
                let tmPend = originalHtml.substring(tmpCharIndex + ev_CharLength).indexOf("\n");
                end = tmPend < 0 ? end : tmPend + tmpCharIndex + ev_CharLength;
              } else if (inIframe() || tooBig /*&& allSelectedNodes.length == 1*/) {
                hasWhiteSpace = true;

                //local_lastDoc.removeAttribute("style");
                //local_lastDoc.style.color = "inherit";
                if (!NotOnboundary && fromOverflow == 0) {
                  spanBefore = styleNodesString();
                  let firstPart = originalHtml.substring(0, tmpCharIndex);
                  //firstPart = firstPart.replace(/-/g, " ");
                  let HilighlitedWordIsAt = firstPart.split(" ").length;
                  let values = measureChild(docsFirstChild, myHilightSpan, HilighlitedWordIsAt - 1);
                  start = values[0];

                  //in case we're overshooting the end index.
                  if (start > tmpCharIndex) {
                    start = tmpCharIndex;
                  }
                  let tmPend = values[1];
                  end = tmPend < 0 ? end : tmPend;
                  if (end < tmpCharIndex + ev_CharLength) {
                    end = originalHtml.length;
                  }
                } else if (fromOverflow > 0) {
                  //measure new elements before they are overwritten with highlit.
                  measureChild(docsFirstChild, myHilightSpan, 0);
                }
              }

              let id = "mycustomreadxhspan 101";
              if (fromOverflow != 0) {
                id = "mycustomreadxhspanof " + fromOverflow;
              }

              docsFirstChild.nodeValue = "";
              myHilightSpan.innerHTML =
                RepLtGt(originalHtml.substring(0, start)) +
                spanBefore +
                RepLtGt(originalHtml.substring(start, tmpCharIndex)) +
                spanBeforeEnd +
                "<customreadxhspan id='" +
                id +
                styleNodesStringAfter(otterranceColor, local_lastDoc) +
                ">" +
                RepLtGt(originalHtml.substring(tmpCharIndex, tmpCharIndex + ev_CharLength)) +
                "</customreadxhspan>" +
                spanBefore +
                RepLtGt(originalHtml.substring(tmpCharIndex + ev_CharLength, end)) +
                spanBeforeEnd +
                RepLtGt(originalHtml.substring(end));
              if (hasWhiteSpace && fromOverflow == 0) {
                if ((start <= tmpCharIndex && start + 5 >= tmpCharIndex) || !isEdge) {
                  try {
                    var sd;

                    var myChildNodes = myHilightSpan.parentNode.childNodes;
                    loop1: for (i = 0; myChildNodes && i < myChildNodes.length; i++) {
                      var subChild = myChildNodes[i].childNodes;
                      for (j = 0; subChild && j < subChild.length; j++) {
                        if (subChild[j].id == id) {
                          sd = subChild[j];
                          break loop1;
                        }
                      }
                    }
                    //var myChildNodes = myHilightSpan.parentNode.childNodes[1].childNodes;
                    sd && autoscroll && sd.scrollIntoView({ behavior: "smooth", block: "center" });
                  } catch (Ex) {
                    console.log(Ex);
                  }
                }
              }

              //console.log(ev_CharIndex + " " + ev_CharLength + " " + tmpOverflow + " " + realCharLength);
              //console.log(myHilightSpan);
              //if there is more text to highlight and it bleeds into the next node

              let tot = ev_CharIndex + realCharLength;
              if (originalHtml.substring(0, 1) == " ") {
                spaceBuffer = 0;
              }
              if (x.charAt(beforelastoffset + tot + spaceBuffer) == "\n" || x.charAt(beforelastoffset + tot + spaceBuffer) == " ") {
                spaceBuffer++;
              }

              if (readMultipleNodes && tmpOverflow > 0 && whatIsTheCurrentNode(tot + spaceBuffer, true) != 0) {
                yellowHighlight("yellow", ev_CharIndex + realCharLength, tmpOverflow, lastDoc, fromOverflow + 1);
              } else {
                spaceBuffer = 0;
              }
            } catch (Ex) {
              console.log(Ex);
            }
          }
        }
      }
      // seems like overkill for what I wanted
      /*function findFirstLetter(str, start, tmpCharIndex) {
  for (i = start; i <= tmpCharIndex; i++) {
    let letter = isItAWord(eraseWords(callReplace(str.charAt(i))), message.voice.name);
    if (letter.length > 0) {
      console.log( i + " " + start + " " + tmpCharIndex);
      return i;
    }
  }
  return -1;
}*/

      var elements;
      var words;
      var allRects = [];
      function measureChild(c1, n1, wordAt) {
        try {
          if (c1.nodeValue != "") {
            allRects = [];
            words = c1.nodeValue; //.replace(/-/g, " ");
            words = words.split(" ");
            var txt = "<measurespan class='measureMeReadX'>";
            for (i = 0; i < words.length; i++) {
              txt += words[i] + " </measurespan>";
              if (i < words.length - 1) {
                txt += "<measurespan class='measureMeReadX'>";
              }
            }
            c1.nodeValue = "";
            n1.innerHTML = txt;

            elements = document.getElementsByClassName("measureMeReadX");

            for (i = 0; i < elements.length; i++) {
              allRects[i] = elements[i].getBoundingClientRect();
              //console.log( allRects[i]  );
              //console.log( words[i]  );
            }
          }

          //if (words[0] == "") {
          //  wordAt++;
          //}

          let rect = allRects[wordAt];
          let startIndex = wordAt - 1;
          for (; startIndex >= 0; startIndex--) {
            let rect2 = allRects[startIndex];
            if (rect.top != rect2.top) {
              break;
            }
          }

          let endIndex = wordAt + 1;
          for (; endIndex < allRects.length; endIndex++) {
            let rect2 = allRects[endIndex];
            if (rect.top != rect2.top) {
              break;
            }
          }

          let start = 0;
          let end = -1;

          txt = "";
          for (i = 0; i < words.length; i++) {
            txt += words[i] + " ";
            if (startIndex == i) {
              start = txt.length;
            }
            if (endIndex - 1 == i) {
              end = txt.length;
            }
          }
          //console.log( start + " end> " + end );
          return [start, end];
        } catch (Ex) {
          console.log(Ex);
        }

        return [0, -1];
      }

      class Node {
        constructor(data, realIndex, next = null, lastIndex = null) {
          this.data = data;
          this.realIndex = realIndex;
          this.lastIndex = lastIndex;
          this.next = next;
        }
      }

      class LinkedList {
        constructor() {
          this.next = null;
          this.size = 0;
        }

        /*Insert into the tail*/
        insertToTail(data, realIndex) {
          const node = new Node(data, realIndex);
          let tail = null;
          if (!this.next) {
            this.next = node;
          } else {
            tail = this.next;
            while (tail.next) {
              tail = tail.next;
            }
            tail.next = node;
          }
          this.size++;
        }
        giveMeTheString() {
          var current = this;
          var str = "";
          for (var i = 0; current.next != null; i++) {
            str += current.next.data;
            current = current.next;
          }

          return str;
        }

        giveMeTheStringAndIndex() {
          var current = this;
          var str = "";
          for (var i = 0; current.next != null; i++) {
            str += "|" + current.next.realIndex + "|";
            str += current.next.data;
            current = current.next;
          }

          return str;
        }

        removeAndReplaceFromIndex(myStart, myLength, newString) {
          var current = this;
          /*traverse to the node before myStart*/

          if (this.size < myStart + myLength) {
            /*console.log("element doesn't exist");*/
            return false;
          }

          for (var i = 0; current.next != null && i < myStart; i++) {
            current = current.next;
          }

          var firstIndex = current.next.realIndex;
          var lastIndex = 0;
          for (var i = 0; i < myLength; i++) {
            if (i + 1 == myLength) {
              lastIndex = current.next.realIndex;
            }
            current.next = current.next.next;
            this.size--;
          }

          var myStringArray = Array.from(newString);
          for (var i = 0; i < myStringArray.length; i++) {
            const node = new Node(myStringArray[i], firstIndex);
            if (myStringArray.length == 1) {
              node.realIndex = firstIndex;
            } else {
              if (i + 1 == myStringArray.length) {
                node.realIndex = lastIndex;
              }
            }

            node.lastIndex = lastIndex;
            node.next = current.next;
            current.next = node;
            current = current.next;
            this.size++;
          }

          return true;
        }
      }

      function processKeyValuesForReplace(key, value, linkedList, OriginalStr) {
        /*tmpStr = replaceWord(tmpStr, key, value, false);*/
        var mykey = key;
        //if (mykey.length == 1) {
        /* we're being lazy here and assuming that anything with 1 char length isn't a regex*/
        //  mykey = regexEscape(key);
        // }
        const reg = new RegExp(mykey, "ig");
        var result;

        var replaceOffset = 0;
        while ((result = reg.exec(OriginalStr)) !== null) {
          /*result[0].length
           result.index*/

          /* regex adjustment, needed to account for $1... variables in regex */
          var my_tmpStr = value;
          //search for $ to replace groups if there are groups and $ is used
          if (result.length > 0 && value.match(/\$\d/gi)) {
            for (var i = 1; i < result.length; i++) {
              var myExp = new RegExp("\\$" + i, "ig");
              my_tmpStr = my_tmpStr.replace(myExp, result[i]);
            }
          }

          //console.log( result.index +" : " +replaceOffset + " | " + result[0].length + " |" + my_tmpStr + "|" );
          //console.log( "|||" + OriginalStr + "|||" );
          var sucess = linkedList.removeAndReplaceFromIndex(result.index + replaceOffset, result[0].length, my_tmpStr);
          if (sucess == true) {
            /* offset the index of next replace, since the linkedList changed */
            replaceOffset += Array.from(my_tmpStr).length - result[0].length;
          }
        }

        OriginalStr = linkedList.giveMeTheString();

        //console.log( OriginalStr + " " + mykey );
        //console.log( linkedList.giveMeTheStringAndIndex() + " " + mykey );
        return OriginalStr;
      }

      function MapForReplace(OriginalStr) {
        const linkedList = new LinkedList();

        /*var OriginalStrArray = Array.from(OriginalStr);
  for (var i = 0; i < OriginalStrArray.length; i++) {
    linkedList.insertToTail(OriginalStrArray[i], i);
  }*/

        // populate the linkdList with char array, the same as what RegEx would understand (â¯Â°â¡Â°)â¯ï¸µ â»ââ»
        for (var i = 0; i < OriginalStr.length; i++) {
          linkedList.insertToTail(OriginalStr.substr(i, 1), i);
        }

        for (const [key, value] of Object.entries(replaceDictionary)) {
          regex = new RegExp(spaceAlternative, "g");
          OriginalStr = OriginalStr.replace(regex, " ");
          OriginalStr = processKeyValuesForReplace(key, value, linkedList, OriginalStr);
        }

        return linkedList;
      }

      function RepLtGt(innerHilight) {
        innerHilight = replaceWord2(innerHilight, "<", "&lt;", true);
        innerHilight = replaceWord2(innerHilight, ">", "&gt;", true);

        return innerHilight;
      }

      function replaceWord2(str, word, replacewith, isRegEx) {
        if (!isRegEx) {
          word = regexEscape(word);
        }
        const regex = new RegExp(word, "ig");
        str = str.replace(regex, replacewith);
        return str;
      }

      function replaceGlobally(original, searchTxt, replaceTxt) {
        const regex = new RegExp(searchTxt, "gi");
        return original.replace(regex, replaceTxt);
      }

      function isDelimiter(letter) {
        if (letter == "." || letter == "!" || letter == "?" || letter == "\n") {
          return true;
        }
        return false;
      }

      function nextParentsElement(indx, tmpStr) {
        var pNode = null;
        let lastHighest = null;
        let attempt = 0;
        var i = 0;
        for (; i < spanxLocations.length - 1; i++) {
          //console.log(getNodeByIndx(i));
          if (spanxLocations[i + 1] <= wordsToNodes[indx]) {
          } else {
            //console.log( "i: " + i );
            //console.log(getNodeByIndx(i));

            if (pNode == null) {
              pNode = getNodeByIndx(i);
            } else {
              compareTo = getNodeByIndx(i);
              if (compareTo != null) {
                if (compareTo.parentNode != pNode.parentNode) {
                  //console.log("not the smae " + (nodesToWords[spanxLocations[i]] - indx - 2));
                  //console.log( "i: " + i );
                  //console.log(getNodeByIndx(i));
                  return nodesToWords[spanxLocations[i]] - indx - 2;
                }

                lastHighest = nodesToWords[spanxLocations[i]] - indx - 2;
                let tmpStr2 = tmpStr.substring(0, lastHighest + 3);
                let foundIt = tmpStr2.match(/[!?.](?:[^0-9a-z])?\n/gi);
                if (foundIt) {
                  //console.log("match " + lastHighest );
                  return lastHighest;
                }
              }
            }
          }
        }
        //if we reached the last element and it hasn't given us an index we want, we do the rest of the strings length.
        if (i == spanxLocations.length - 1) {
          console.log(x.length - indx - 1);
          return x.length - indx - 1;
        }
        return lastHighest;
      }

      function getNodeByIndx(indx) {
        mappingMultipleNodes = true;
        var id = spanidOfAlldescendants[indx];

        if (lastDoc && lastDoc.firstChild && lastDoc.firstChild === alldescendants[id]) {
          return alldescendants[id].parentNode; // return parent node for compareison of ogiginal parent.
        }
        if (id >= 0 && alldescendants[id] && trimmer(alldescendants[id].nodeValue).length > 0 && alldescendants[id].nodeValue.trim().length > 0) {
          mappingMultipleNodes = false;
          return alldescendants[id];
        }
        mappingMultipleNodes = false;
        return null;
      }

      function getIndex(str, start) {
        // do not confuse start with lastoffset, this value is incremented to for each itteration.

        //replaces all need for finding strings by just reading the whole thing and highlighting the currrent sentence. when on edge
        /*if (_ultrafast) {
    return str.length + 1;
  }*/

        let m = null;
        offsetbyregex = true;
        //two letter words at the end will not be delimited if followed by a . without an |\n
        //let patt = /(?<![A-Z][a-z]{1,2})(?:!|\.\n|\n|\."|\. "|\. [^a-z|^0-9]|\. [A-Z]|\?)/;
        let patt = /(?<![A-Z][a-z]{1,2})(?:\! [^a-z|^0-9]|\? [^a-z|^0-9]|\. [^\.|^a-z|^0-9])|(\."|\?|\!|\n)/;

        if (isEdge == false) {
          //let patt = /[\.!?]/ ;
          var tmpStr = str.substring(start);
          m = patt.exec(tmpStr);

          if (m != null && m.index != null) {
            delimiterstr = isLongerthan(str, m.index, _maximumChars, start);
            delimiterstr = ifEndsinQuotes(str, delimiterstr);
            return delimiterstr;
          } else {
            delimiterstr = isLongerthan(str, str.length - start, _maximumChars, start);
            delimiterstr = ifEndsinQuotes(str, delimiterstr);
            return delimiterstr; //str.length + 1;
          }
        } else if (!NotOnboundary && readMultipleNodes && isEdge) {
          patt = /\n/;
          var tmpStr = str.substring(start);
          m = patt.exec(tmpStr);
          if (m != null && m.index != null) {
            // gets the next parents element to see if its <br> while being same parent
            // makes sure that <br> isn't cut off if we're reading more to avoid reading to middle of centence.
            let npe = nextParentsElement(start - 1, tmpStr);
            tmpStr2 = tmpStr.substring(0, m.index + 3);
            let foundIt = tmpStr2.match(/[!?.](?:[^0-9a-z])?\n/gi);

            //console.log( tmpStr2 + "|" );
            //console.log(m.index + 1 + " < " + npe + " " + foundIt);
            //console.log( "QQ" + str.substring(0, m.index + start + 15) + "QQ" );
            //console.log( "|" + str.substring(m.index + start, m.index + start + 15) + "|" );

            offsetbyregex = false; // added to make sure the next word isn't cut off by 1 letter.
            if (npe && m.index + 1 < npe && !foundIt) {
              m.index = npe;
            }
          }

          if (m != null && m.index != null) {
            delimiterstr = isLongerthan(str, m.index, _maximumChars, start);
            delimiterstr = ifEndsinQuotes(str, delimiterstr);
            return delimiterstr;
          } else {
            delimiterstr = isLongerthan(str, str.length - start, _maximumChars, start);
            delimiterstr = ifEndsinQuotes(str, delimiterstr);
            return delimiterstr; //str.length + 1;
          }
        }

        start = start || 0;
        //let m = patt.exec(str.substring(start).replace(/[\u201C\u201D]/g, '"'));
        m = null;

        if (readMultipleNodes) {
          //subtract one char to make sure the delimiter starts
          if (start > 0 && !isDelimiter(str.charAt(start - 1))) {
            start = start - 1;
          }

          var tmpStr = replaceGlobally(str.substring(start, start + _maximumChars + 100), spaceAlternative, " ");
          tmpStr = replaceGlobally(tmpStr, NullSpaceAlternative, " ");
          m = patt.exec(tmpStr);
        } else {
          m = patt.exec(str.substring(start, start + _maximumChars + 100));
        }

        var tmpStart = start;
        delimiterstr = -1;

        if (m != null && m.index != null) {
          offsetbyregex = false;
          /* google online voice allows maximum of about 220 characters*/
          delimiterstr = isLongerthan(str, m.index, _maximumChars, start);
          delimiterstr = ifEndsinQuotes(str, delimiterstr);
        }

        if (readMultipleNodes && nodesToWords) {
          // removed for now PPPPPPPPPPPPPPPPPPPPPPPPP 8/25/2021
          //if( typeof wordsToNodes[tmpStart] == 'undefined' ){ //if the last char in the text is not a-z
          //  return isLongerthan(str, (str.length-1)-start-1, _maximumChars, start);
          //}
          loop1: for (var i = 0; i < spanxLocations.length; i++) {
            if (nodesToWords[spanxLocations[i]] < 0 || tmpStart > nodesToWords[spanxLocations[i]]) {
            } else {
              // if the delimiter wasn't found then delimit by spanxLocations
              if (delimiterstr < 0 /*|| delimiterstr > nodesToWords[spanxLocations[i+1]]*/) {
                //if( spanxLocations[i+10] != null ){
                //delimiterstr = nodesToWords[spanxLocations[i+10]];
                var newIndex = str.length - start; // longer than (300) max, so it would trigger
                delimiterstr = isLongerthan(str, newIndex, _maximumChars, start);
                delimiterstr = ifEndsinQuotes(str, delimiterstr);
                //}
              }

              tmpStart = nodesToWords[spanxLocations[i]];
              tmpStart = isLongerthan(str, tmpStart - start - 1, _maximumChars, start);
              offsetbyregex = false;

              break loop1;
            }
            if (i == spanxLocations.length - 1) {
              offsetbyregex = false;
              return isLongerthan(str, str.length - start - 1, _maximumChars, start);
            }
          }
        } else {
          loop1: for (var i = 0; i < spanxLocations.length; i++) {
            if (tmpStart > spanxLocations[i]) {
            } else {
              tmpStart = spanxLocations[i];
              tmpStart = isLongerthan(str, tmpStart - start - 1, _maximumChars, start);
              offsetbyregex = false;
              break loop1;
            }
            if (i == spanxLocations.length - 1) {
              offsetbyregex = false;
              return isLongerthan(str, str.length - start, _maximumChars, start);
            }
          }
        }

        if (delimiterstr != -1 && (readMultipleNodes || delimiterstr <= tmpStart)) {
          return delimiterstr;
        } else {
          if (isNaN(tmpStart)) {
            return isLongerthan(str, str.length - start, _maximumChars, start);
          }

          //tmpStart behaves differently for single div elements
          if (readMultipleNodes && nodesToWords) {
            return isLongerthan(str, str.length - start, _maximumChars, start);
          } else {
            return tmpStart;
          }
        }
      }

      function isLongerthan(str, index, max, start) {
        if (isEdge && index > max) {
          //let patt = RegExp(/([^.!?,]*)$/, "g");
          //let m = patt.exec(str.substring(start, start + max));
          let mystr = str.substring(start + max, start + index);
          let patt = RegExp(/([.!?] )/, "g");
          let m = patt.exec(mystr);

          //check where the next \n is.
          // so if the sentece ends soon anyway we don't bother cutting it up for no reason.
          // also somewhat reduces the chance of getting stand alone non alphanumerc chars at the end of the sentence.
          let newLinematch = /\n/.exec(mystr);
          let compareto = str.length;
          if (newLinematch && newLinematch.index) {
            compareto = newLinematch.index;
          }

          if (m && m.index > 1 && m.index + 10 < compareto) {
            return max + start + m.index + 1;
          } else {
            return index + start;
          }
        }

        if (index > max) {
          var tmpStr = str.substring(start, start + max);
          var cutOff = Math.max(tmpStr.lastIndexOf(", "), tmpStr.lastIndexOf(". "));

          if (cutOff == -1) {
            cutOff = tmpStr.lastIndexOf(" ");
            if (cutOff && cutOff > 0) {
              cutOff--;
            }
          }
          if (cutOff != -1) {
            return start + cutOff + 1;
          } else {
            return start + max;
          }
        } else {
          return index + start + 1;
        }
      }

      function isLetter(str) {
        //console.log( str );
        return str.length === 1 && str.match(/[a-z|0-9]|[\!\.\?]/i) != null;
      }

      function ifEndsinQuotes(str, delimiterstr) {
        // using \n for edge delimiter so no need to advance for quotes.
        //console.log( "|" + str.charAt(delimiterstr) + "|" );
        //console.log( "|" + str.charAt(delimiterstr-1) + "|" );
        if (/*isEdge ||*/ delimiterstr > 0 && str.charAt(delimiterstr - 1) == "\n") {
          //console.log( "|" + str.charAt(delimiterstr) + "|" );
          return delimiterstr - 1;
        }

        /* check if the last char was \n so a quote from the next line won't be carried over */
        if (str.charAt(delimiterstr - 1) == "\n") {
          return delimiterstr;
        }

        /* advance by one letter if the sentence ends with a character that's not a space 
     pretty much makes the rest of the code under this unnecessary
  */
        //console.log( " " + str.charAt(delimiterstr-1));
        if (str.charAt(delimiterstr) != " " && str.charAt(delimiterstr + 1) == " ") {
          //console.log( "added one |" + str.charAt(delimiterstr-1));
          return delimiterstr + 1;
        }

        /*myStr = str
    .substring(delimiterstr, delimiterstr + 1)
    .replace(/[\u201C\u201D"]/g, "ZZ");
  if (myStr == "ZZ") {
    delimiterstr = delimiterstr + 1;
  }*/

        return delimiterstr;
      }

      function addXLength(tmpLength) {
        if (_mapping_xLength) {
          _ultra_xLength += tmpLength;
        }
      }

      var allEventNodes = [];
      var alldescendants = [];
      var allowBR = false;
      function recurseAndAdd(el, descendants, fromshadow = false) {
        var children = el.childNodes;
        var tmpLength = 0;

        if (children == null || children.length == 0) {
          if ((allowBR && el.nodeName.match(/\bbr\b/gi)) || (el.nodeValue != null && (tmpLength = trimmer(el.nodeValue).length) > 0)) {
            if (el.nodeValue != null && (tmpLength = noSpacesTrimmer(el.nodeValue).length)) {
              addXLength(tmpLength);
            }
            descendants.push(el);
          }
        } else {
          for (let i = 0; i < children.length; i++) {
            if (children[i].shadowRoot) {
              recurseAndAdd(children[i].shadowRoot, descendants, true);
            }
            if (children[i].childNodes.length != 0 && !children[i].innerText) {
              if (isItHidden(children[i]) == false && checker(children[i].tagName.toLowerCase())) {
                recurseAndAdd(children[i], descendants, fromshadow);
              }
            } else if (
              children[i].childNodes.length == 0 ||
              (children[i].innerText != null && trimmer(children[i].innerText, false, /\n/).length > 0 && checker(children[i].tagName.toLowerCase()))
            ) {
              if ((children[i].nodeType && children[i].nodeType == 8) || isItHidden(children[i]) == true) {
              } else {
                recurseAndAdd(children[i], descendants, fromshadow);
              }
            }
          }
        }
      }

      /*function recurseAndAdd(el, descendants) {
  var children = el.childNodes;
  if (children.length == 0) {
    if (el.nodeValue != null) {
      descendants.push(el);
    }
  } else {
    for (let i = 0; i < children.length; i++) {
      if (
        isItHidden(el) == false &&
        isItHidden(children[i]) == false &&
        (children[i].childNodes.length == 0 ||
          (children[i].innerText != null &&
            trimmer(children[i].innerText).length > 0 &&
            checker(children[i].tagName.toLowerCase())))
      ) {
        recurseAndAdd(children[i], descendants);
      }
    }
  }
}*/

      function isAlreadyInArray(el, destination) {
        for (var j = 0, max = destination.length; j < max; j++) {
          if (destination[j] === el) {
            return;
          }
        }
        destination.push(el);
      }

      function strip(html) {
        let doc = new DOMParser().parseFromString(html, "text/html");
        return doc.body.textContent || "";
      }

      function partialNode(wrapper, myString, spanid, alldescendants) {
        let wrapper2 = createSpan(spanid);
        var cn = alldescendants.cloneNode(false);
        cn.nodeValue = myString;
        wrapper2.appendChild(cn);
        insertAfter(wrapper, wrapper2);
        return wrapper2;
      }

      function checker(value) {
        var prohibited = ["script", "option", "input", "title"];

        for (var i = 0; i < prohibited.length; i++) {
          if (value.indexOf(prohibited[i]) > -1) {
            return false;
          }
        }
        return true;
      }

      function isItHidden(x) {
        try {
          if (x.nodeName.match(/\bbr\b/gi)) {
            return false;
          }

          if (
            x.nodeType === Node.COMMENT_NODE ||
            (x instanceof HTMLElement &&
              (x.getAttribute("aria-hidden") == "true" || window.getComputedStyle(x).display === "none" || window.getComputedStyle(x).visibility === "hidden"))
          ) {
            return true;
          }
        } catch (E) {
          /*    console.log( E );*/
        }

        return false;
      }

      function createSpan(spanid) {
        var wrapper = document.createElement("customreadxspan"); // changed span to customreadxspan
        wrapper.setAttribute("id", "ttsh" + spanid);
        setInheritColor(wrapper);

        return wrapper;
      }

      function setInheritColor(e) {
        try {
          e.style.color = "inherit";
        } catch (E) {}
      }

      function mapNodesFromRootVal(t, descendants) {
        if (document && document.body && document.body.children) {
          for (let i = 0; i < t.length; i++) {
            var tmpNode;
            if (t[i].shadowRoot) {
              tmpNode = t[i].shadowRoot;
              recurseAndAdd(tmpNode, descendants, true);
            }
            tmpNode = t[i];
            if (trimmer(tmpNode.innerText).length > 0) {
              if (isItHidden(tmpNode) == false && checker(tmpNode.tagName.toLowerCase())) {
                recurseAndAdd(tmpNode, descendants);
              }
            }
          }
        }
      }

      /*
function mapNodesFromRootVal(t, descendants) {
  if (document && document.body && document.body.children) {
    for (let i = 0; i < t.length; i++) {
      if (trimmer(t[i].innerText).length > 0) {
        if (isItHidden(t[i]) == false && checker(t[i].tagName.toLowerCase())) {
          recurseAndAdd(t[i], descendants);
        }
      }
    }
  }
}*/

      function getNextTarget(_curentTarget) {
        for (var i = _ultra_index; i < _ultra_descendants.length; i++) {
          /*the way it "works":
      it first finds the current target and sets the index
      the index is used for everything after that.
    */

          var targetIndex = -1;
          if (_ultra_index == 0) {
            if (_curentTarget == _ultra_descendants[i].parentNode || _curentTarget == _ultra_descendants[i] || isBookMark(_ultra_descendants[i])) {
              targetIndex = i;
            } else {
              _ultra_xLengthRead += trimmer(_ultra_descendants[i].nodeValue).length;
            }
          } else {
            targetIndex = _ultra_index;
          }

          if (targetIndex >= 0) {
            values = traverseTargets(targetIndex);
            if (values[1] != null) {
              _ultra_index = values[1]; // update the index!!!!
            }
            return values; //0th element is the target
          }
        }
        return null;
      }

      function hasWhiteSpaceStyle(my_node) {
        //disabled it, because I didn't like how it was displaying the highlights.
        return false;
        try {
          const WSMatch = /\bpre\b|\bpre-wrap\b|\bpre-line\b|\break-spaces\b/gi;
          let whiteSpace = window.getComputedStyle(my_node.parentNode).whiteSpace; // ultraNode[j].parentNode.style.whiteSpace;
          if (whiteSpace.match(WSMatch)) {
            return true;
          } else {
            return false;
          }
        } catch (Ex) {
          //console.log(Ex);
        }
        return false;
      }

      //used to traverse targets, pass false to look ahead without committing the data, as long as _ultra_index is > 0
      function traverseTargets(targetIndex, commit = true) {
        var ultraNode = _ultra_descendants;
        for (var j = targetIndex; j < ultraNode.length; j++) {
          try {
            if (ultraNode[j].nodeName.match(/\bbr\b/gi)) {
              let tmpBR = "\n";
              if (window.getComputedStyle(ultraNode[j]).display === "none") {
                tmpBR = "";
              }
              if (commit) {
                //addBuffer( tmpBR );
                _ultra_Xstr += tmpBR;
              }

              return [ultraNode[j], j + 1, tmpBR];
            } else if (ultraNode[j] && ultraNode[j].nodeValue) {
              var tmpStr = ultraNode[j].nodeValue;
              tmpStr = callReplace(tmpStr);
              if (!hasWhiteSpaceStyle(ultraNode[j])) {
                tmpStr = replaceGlobally(tmpStr, "\n", " ");
              }

              if (trimmer(tmpStr).length > 0) {
                var NewLineOrSpaceOrNothing = "";
                if (tmpStr != " " && (trimmer(tmpStr, true).length > 0 || areThereDelimiters(tmpStr))) {
                  const regxMatch = /\bspan\b|\bstrong\b|\bem\b|\bsup\b|\bi\b|\bcode\b|\ba\b|\bb\b|\btime\b|\bkbd\b|\bmark\b|\bsamp\b|\bsub\b|\bu\b|\bwbr\b|\bvar\b/gi;
                  if (ultraNode[j].parentNode.tagName.match(regxMatch)) {
                    NewLineOrSpaceOrNothing = whatToAdd(findTopParent(ultraNode[j], regxMatch), commit);

                    if (ultraNode[j].parentNode.tagName.match(/\ba\b/gi)) {
                      NewLineOrSpaceOrNothing += " ";
                    }
                  } else {
                    NewLineOrSpaceOrNothing = whatToAdd(ultraNode[j], commit);
                  }

                  if (commit) {
                    //addBuffer(NewLineOrSpaceOrNothing + tmpStr);
                    _ultra_Xstr += NewLineOrSpaceOrNothing + tmpStr;
                  }
                } else {
                  if (commit) {
                    //addBuffer( tmpStr );
                    _ultra_Xstr += tmpStr;
                  }
                }

                if (commit) {
                  addBuffer(trimmer(ultraNode[j].nodeValue).length);
                }
                return [ultraNode[j], j + 1, NewLineOrSpaceOrNothing];
              }
            }
          } catch (Ex) {
            //console.log(Ex);
          }
        }

        return [null, null, null];
      }

      function findTopParent(node, regxMatch) {
        while (node.parentNode.tagName.match(regxMatch)) {
          node = node.parentNode;
        }
        return node;
      }

      function doesTopParentMatch(node, matchID) {
        while (node.id != matchID && node.parentNode) {
          node = node.parentNode;
        }
        return node.id == matchID;
      }

      var wasBr = false;
      function addBuffer(BLength) {
        //trimmer(_ultra_descendants[i].nodeValue).length
        _ultra_xLengthBuffer += BLength;
      }

      /*function findNewLine(str, strToFind) {
  var myReg = new RegExp(regexEscape(strToFind.trim()), "igm");
  var foundAt = str.search(myReg);
  if (foundAt >= 0) {
    return isThereNoSpace(str, foundAt + strToFind.trim().length);
  }
}*/

      function isCurrentItemFollowedByANewLine() {
        if (_ultra_index > 0) {
          var values = traverseTargets(_ultra_index, false);
          //console.log( values[0] );
          //console.log( "V:= " + (values[2] == "\n") + " " + values[0].nodeValue + " UL:" + _ultra_Loops );
          if (values && values[2] != null) {
            return values[2] == "\n";
          } else {
            return true; // reached the end so it doesn't matter.
          }
        }
        return false;
      }

      function areThereMoreElements() {
        if (_ultra_index > 0) {
          var values = traverseTargets(_ultra_index, false);
          if (values && values[2] != null) {
            return true;
          } else {
            return false; // reached the end
          }
        }
        return true; //return true, haven't started reading;
      }

      function checkIt(rectA, rectB) {
        // if it's negative top because it's a div in the middle of a bunch of spans, return false.
        // there has to be a better way to do this.
        if (rectA.top < 0 || rectB.top < 0) {
          return false;
        }
        return rectA.top + rectA.height / 2 >= rectB.top;
      }

      //check if the height is not the same
      function theSame(rectA, rectB) {
        if (rectA.top == rectB.top) {
          return true;
        }
        if (rectA.top < rectB.top) {
          return checkIt(rectA, rectB);
        } else {
          return checkIt(rectB, rectA);
        }
      }

      function printRect(rect) {
        x = rect.left;
        y = rect.top;
        w = rect.width;
        h = rect.height;
        console.log("Left: " + x + ", Top: " + y + ", Width: " + w + ", Height: " + h);
      }

      // measure the rectangle of an object and return if it's below or next to previous one
      function whatToAdd(node, commit = true) {
        /*const pointInRect = (x1, y1, x2, y2, x, y) =>
  x > x1 && x < x2 && y > y1 && y < y2;*/

        var addition = "";
        var rect = node.parentNode.getBoundingClientRect();

        /*if( commit ){
    console.log( node.parentNode );
    console.log( node.nodeValue);
    console.log (rect);
  }*/
        if (_ultra_lastRect != null) {
          if (_ultra_lastRect == rect) {
            addition = "";
          } else if (pointInRect(_ultra_lastRect.left, _ultra_lastRect.top, _ultra_lastRect.right, _ultra_lastRect.bottom, rect.left, rect.top)) {
            addition = "";
          } else if (_ultra_lastRect.bottom == rect.bottom && pointInRect(rect.left, rect.top, rect.right, rect.bottom, _ultra_lastRect.left, _ultra_lastRect.top)) {
            //added recently, not sure if accurate
            addition = "";
          } else if (!theSame(_ultra_lastRect, rect)) {
            addition = "\n";
          } else if (_ultra_lastRect.left == rect.left && _ultra_lastRect.top == rect.top) {
            //if it's the same parent, don't add spaces
            addition = "";
          } else {
            addition = " ";
          }
        }
        if (commit) {
          _ultra_lastRect = rect;
        }
        return addition;
      }

      // readTargets.parentNode !== _curentTarget
      // makes sure the selected text is read from charIndex even if there are other elements in between.
      function insideCur(red, cur) {
        let p = 0;
        while (red !== null && p < 200) {
          if (red === cur) {
            return true;
          }
          p++;
          red = red.parentNode;
        }
        return false;
      }

      function mapIndexForHighlight() {
        /*console.log("mapping indexes");*/

        if (readMultipleNodes == true) {
          mappingMultipleNodes = true;
          allowBR = true;
        }

        _ultrafast = true;
        if (document && document.body && document.body.children) {
          /*var t = document.getElementsByTagName('*');*/

          if (readMultipleNodes == true) {
            var sbHeight = document.body.scrollHeight;
            /*console.log( sbHeight );*/

            if (sbHeight > 15000) {
              _ultrafast = true;
            } else {
              _ultrafast = true;
            }
          }

          if (_ultrafast) {
            if (doc != null) {
              removeMyHighlight();
            }

            //reset these variables on new itteration.
            if (alldescendants.length == 0) {
              _ultra_descendants = [];
              _ultra_index = 0;
              _ultra_xLength = 0;
              _ultra_xLengthBuffer = 0;
              _ultra_xLengthRead = 0;
              _ultra_lastRect = null;

              totalReadStrLen = 0;
              lastReadstr = "";
              var t = document.body.children;

              _mapping_xLength = true;
              mapNodesFromRootVal(t, _ultra_descendants);
              _mapping_xLength = false;
            } else {
              _ultra_xLengthRead += _ultra_xLengthBuffer;
              _ultra_xLengthBuffer = 0;
              totalReadStrLen = 0;
              lastReadstr = "";
            }

            alldescendants = [];
            nodesToWords = [];
            wordsToNodes = [];
            _ultra_Xstr = "";

            //console.log( "U INDX: " + _ultra_index );
            var i;
            var nextTarget;

            for (i = 0; _curentTarget && (nextTarget = getNextTarget(_curentTarget)) != null; i++) {
              //let nextTarget = getNextTarget(_curentTarget); // zeroth element is the target
              if (nextTarget && nextTarget[0]) {
                if (!nextTarget[0].nodeName.match(/\bbr\b/gi)) {
                  alldescendants.push(nextTarget[0]);
                }
              } else {
                break;
              }
              _ultra_Loops = i;

              var readTargets = traverseTargets(_ultra_index, false)[0];
              if (readTargets && (richCaretIndex == 0 || !insideCur(readTargets, _curentTarget)) && readTargets.parentNode !== nextTarget[0].parentNode) {
                //limiting the amount of data the for loop can grab while ensuring it's not going to be empty.
                if ((_ultra_xLengthBuffer > 600 || (_ultra_xLengthBuffer > 400 && i > 30)) && isCurrentItemFollowedByANewLine()) {
                  break;
                }
                if (_ultra_xLengthBuffer > 2500 || (_ultra_xLengthBuffer > 1500 && i > 40)) {
                  break;
                }
              }
            }

            _ultra_Loops = i;
            //console.log("_ultra_Xstr");
            //console.log(_ultra_Xstr);
          } else {
            var t = document.body.children;
            mapNodesFromRootVal(t, alldescendants);
          }

          /*var t = document.getElementsByTagName("*");
    for (var i = 0; i < t.length; i++) {
      if (t[i] instanceof HTMLElement) {
        if (isItHidden(t[i]) == false && checker(t[i].tagName.toLowerCase())) {
          recurseAndAdd(t[i], alldescendants);
        }
      }
    }*/

          /*if (document.body.shadowRoot) {
      recurseAndAdd( document.body.shadowRoot, alldescendants );
    }*/
        } else {
          return;
        }

        var willBeX = "";
        /*x = "";*/
        stitch = "";
        var spanid = 0;
        var j = 0;
        spanxLocations = [];
        spanidOfAlldescendants = Array(alldescendants.length).fill(-1);
        alldescendantsToSpanid = Array(alldescendants.length).fill(-1);

        if (readMultipleNodes == true) {
          nospaceAtTheend = null;
          nospaceAtBeginning = null;
          if (_ultrafast) {
            x = _ultra_Xstr;
          } else {
            x = callReplace(document.body.innerText);
          }
        }

        var tmpStr = "";
        for (var i = 0, max = alldescendants.length; i < max; i++) {
          tmpStr = alldescendants[i].nodeValue;
          tmpStr = callReplace(tmpStr);
          tmpStr = replaceGlobally(tmpStr, "\n", " ");

          if (trimmer(tmpStr).length > 0) {
            if (readMultipleNodes == true && _ultrafast == false) {
              stitchIt(x, tmpStr);
            }

            spanxLocations.push(willBeX.length);
            willBeX += tmpStr;
            spanidOfAlldescendants[spanid] = i;
            alldescendantsToSpanid[i] = spanid;
            spanid++;
          }
        }

        spanxLocations.push(willBeX.length);
        /*console.log( willBeX );*/

        if (readMultipleNodes == false) {
          x = willBeX;
        } else {
          //console.log( "_ultra_Xstr" );
          //console.log( _ultra_Xstr );

          if (_ultrafast) {
            x = replaceWord(_ultra_Xstr, "\\s+", " ");
          } else {
            x = replaceWord(stitch, "\\s+", " ");
          }

          //console.log( x );
          /*x = stitch.replace(/\s+/g, " ");*/
          //x = callReplace(stitch); //callReplace(document.body.innerText);
          mapWordsToNodes(x, willBeX);
          mappingMultipleNodes = false;
          allowBR = false;

          x = eraseWords(x);
          //console.log("outputting X ");
          //console.log(x);
        }
      }

      function isThereNoSpace(string, inx) {
        var word_regexp = /\s/;
        if (string.charAt(inx).match(word_regexp)) {
          if (string.charAt(inx) == "\r" || string.charAt(inx) == "\n") {
            return 2;
          }
          return 0;
        } else {
          return 1;
        }
      }

      var stitch = "";
      var nospaceAtTheend;
      var nospaceAtBeginning;
      var nospaceInTheMiddle;
      function stitchIt(str, strToFind) {
        var myReg = new RegExp(regexEscape(strToFind.trim()), "igm");
        var foundAt = str.search(myReg);
        if (foundAt >= 0) {
          nospaceAtBeginning = isThereNoSpace(strToFind, 0);

          if ((nospaceAtTheend = !null)) {
            if (nospaceAtTheend == 1 && nospaceInTheMiddle == 0 && nospaceAtBeginning == 1) {
              stitch += " ";
              /*console.log( strToFind + ' new lined' );*/
            } else if (/*nospaceAtTheend == 1 &&*/ nospaceInTheMiddle == 2 /*&&  nospaceAtBeginning == 1*/) {
              stitch += "\n";
              //^^ originally checked for both sides but then realized when there is a \n it's a delimiter.
              /*console.log( strToFind + ' spaced' );*/
            }
          }

          nospaceInTheMiddle = isThereNoSpace(x, foundAt + strToFind.trim().length);
          nospaceAtTheend = isThereNoSpace(strToFind, strToFind.length - 1);
          stitch += strToFind;
          x = x.substring(foundAt + strToFind.trim().length);
        } else {
          /* In case it's shadow dom and isn't part of the document */
          /*console.log( strToFind + 'failed to find in document' );*/
          stitch += strToFind;
          stitch += " ";
        }
        myReg = null;
      }

      var wordsToNodes;
      var nodesToWords;
      function mapWordsToNodes(x, willBeX) {
        wordsToNodes = [];
        nodesToWords = [];

        wordsToNodes = Array(willBeX.length).fill(-1);
        nodesToWords = Array(willBeX.length).fill(-1);

        var testStr = "";

        var j = 0;
        for (var i = 0; i < willBeX.length && j < x.length; i++) {
          var word_regexp = /\s/;
          while (willBeX.charAt(i).match(word_regexp) && i < wordsToNodes.length - 1) {
            nodesToWords[i] = j;
            i++;
          }
          while (x.charAt(j).match(word_regexp) && j < x.length - 1) {
            wordsToNodes[j] = i;
            j++;
          }

          while (willBeX.charAt(i).toLowerCase() != x.charAt(j).toLowerCase() && j < wordsToNodes.length - 1) {
            wordsToNodes[j] = i;
            j++;
          }

          if (willBeX.charAt(i).toLowerCase() == x.charAt(j).toLowerCase()) {
            nodesToWords[i] = j;
            wordsToNodes[j] = i;
            /*testStr += willBeX.charAt(i)*/
            /*testStr += x.charAt(j);*/
            j++;
          }
        }
        /*console.log(testStr);*/
      }

      var isPaused = 0;
      function pauseForAfew(ms = 400) {
        isPaused = 1;
        var interval = setInterval(function () {
          isPaused = 0;
          clearInterval(interval);
        }, ms);
      }

      function callReplace(tmpStr) {
        tmpStr = MapForReplace(tmpStr).giveMeTheString();
        /*for (const [key, value] of Object.entries(replaceDictionary)) {
    tmpStr = replaceWord(tmpStr, key, value);
  }*/

        var reg = new RegExp(unified_emoji_ranges.join("|"), "g");
        if (readMultipleNodes == true) {
          tmpStr = tmpStr.replace(reg, spaceAlternative);
        } else {
          tmpStr = tmpStr.replace(reg, " ");
        }

        /*Remove accents / diacritics in a string*/
        /*tmpStr = tmpStr.normalize("NFD").replace(/[\u0300-\u036f]/g, "");*/

        return tmpStr;
      }

      function regexEscape(str) {
        return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }

      function replaceWord(str, word, replacewith) {
        if (trimmer(str).length > 0) {
          var mykey = word;
          //if (mykey.length == 1) {
          /* we're being lazy here and assuming that anything with 1 char length isn't a regex*/
          //mykey = regexEscape(word);
          //}

          const regex = new RegExp(mykey, "ig");

          /*preserves new lines, but after writing it, I'm not sure if I even want that capability*/
          if (readMultipleNodes && mykey == "\\s+") {
            var result;
            var newstr = "";
            var start = 0;
            while ((result = regex.exec(str)) !== null) {
              newstr += str.substring(start, result.index);
              start = regex.lastIndex;

              var word_regexp = /\n/;
              if (result[0].match(word_regexp)) {
                newstr += "\n";
              } else {
                newstr += replacewith;
              }
            }
            if (start > 0) {
              newstr += str.substring(start);
              return newstr;
            } else {
              return str;
            }
          }

          str = str.replace(regex, replacewith);
          return str;
        }

        return "";
      }

      function insertAfter(referenceNode, newNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
      }

      function noSpacesTrimmer(myTrim) {
        if (myTrim.replace(/\s+/, " ") == " ") {
          return "";
        }

        var myTrim2 = myTrim.replace(/[\s\.\'\?"!\u2026\u201C\u201D\u2018\u2019\u200B]*/g, "");
        return myTrim2;
      }

      function trimmer(myTrim, override = false, extraAllowed) {
        if (myTrim == null) {
          return "";
        }

        if (myTrim.replace(/\s+/, " ") == " ") {
          return " ";
        }

        //var myTrim2 = myTrim.replace(/[\s\.\'\?"!\*\u2026\u201C\u201D\u2018\u2019\u200B]*/g, "");
        var myTrim2 = myTrim.replace(/[\s\.\'\?"!\u2026\u201C\u201D\u2018\u2019\u200B]*/g, "");
        if (override == false && myTrim2.length <= 0 && readMultipleNodes == true && mappingMultipleNodes == true) {
          /* added space for 'no gap' highlighting of continuous text */
          var word_regexp = /[\.\?\!'" ]|[\u2018\u2019\u201A\u201B\u2032\u2035]|[\u201C\u201D\u201E\u201F\u2033\u2036]/;
          if (myTrim.match(word_regexp)) {
            return " ";
          }
          if (extraAllowed) {
            if (myTrim.match(extraAllowed)) {
              return " ";
            }
          }
        }
        return myTrim2; //myTrim.replace(/[\s\.\'\?"!\*\u2026\u201C\u201D\u2018\u2019]*/g, "");
        /*return myTrim.replace(/^\s+|\s+$/gm,'');*/
      }

      function areThereDelimiters(myTrim) {
        var word_regexp = /[\.\?\!'"]|[\u2018\u2019\u201A\u201B\u2032\u2035]|[\u201C\u201D\u201E\u201F\u2033\u2036]/;
        if (myTrim.match(word_regexp)) {
          return true;
        }
        return false;
      }

      function wrap(el, wrapper) {
        try {
          el.parentNode.insertBefore(wrapper, el);
          wrapper.appendChild(el);
        } catch (Ex) {
          lastDoc = null;
          doc = null;
          console.log(Ex);
        }
      }

      function pause() {
        canceled = true;
        if (allSelectedNodes && allSelectedNodes.length > 0) {
          addDialogToNode(allSelectedNodes[allSelectedNodes.length - 1]);
        } else if (lastDoc != null) {
          addDialogToNode(lastDoc);
        }

        bookmarkPauseLocation();

        window.speechSynthesis.cancel();
        sendMessageToBackground("paused");
      }

      function isBookMark(ultraNode) {
        if (_ultrafast && trimmer(ultraNode.nodeValue).length > 0 && trimmer(bookmarkString).length > 0) {
          if (ultraNode.nodeValue == bookmarkString) {
            bookmarkString = "";
            return true;
          }
        }
        return false;
      }

      function bookmarkPauseLocation() {
        //console.log(window.location.href);
        //console.log(childsNodeValue);
        saveBookmarkToStorage(window.location.href, childsNodeValue);
      }

      function saveBookmarkToStorage(key, value) {}

      function pushKey(indexedArray, key, urlArray) {
        var newArray = [];
        var j = 0;
        for (i = 0; indexedArray != null && i < indexedArray.length; i++) {
          if (indexedArray[i] == key) {
          } else {
            newArray[j] = indexedArray[i];
            j++;
          }
        }
        newArray.push(key);

        if (newArray.length > 250) {
          const firstElement = newArray.shift();
          delete urlArray[firstElement];
        }

        return newArray;
      }

      var bookmarkString = "";
      var pressedOnBookmarkOrPlay = false;
      function getBookmarkFromStorage(key) {}

      function changeSpeechCircleColor() {
        try {
          if (speechCircle && speechCircle.style) {
            if (speechCircle.style.backgroundColor == "rgb(27, 73, 228)" || !readMultipleNodes) {
              speechCircle.style.backgroundColor = "#2196F3";
            } else if (pressedOnBookmarkOrPlay == false && trimmer(bookmarkString).length > 0) {
              speechCircle.style.backgroundColor = "#1B49E4";
            }
          }
        } catch (Ex) {
          console.log(Ex);
        }
      }

      function addDialogToNode(node) {
        return false;

        var MySettingsbutton = document.createElement("BUTTON");
        MySettingsbutton.innerHTML = "...";
        MySettingsbutton.addEventListener("click", openDialog);

        node.appendChild(MySettingsbutton);

        Mydialog = document.createElement("DIALOG");

        var form = document.createElement("form");
        var Mylabel = document.createTextNode("Change Voice");
        var para = document.createElement("P");
        var selectList = document.createElement("select");
        var myMenu = document.createElement("MENU");
        var MyOKbutton = document.createElement("BUTTON");
        var MyCancelbutton = document.createElement("BUTTON");
        var mySpeed = document.createElement("span");
        var myInput = document.createElement("input");

        form.setAttribute("method", "dialog");
        para.innerText = "";
        Mydialog.setAttribute("style", "font-size:initial;transform:translate(0, -50%);top:50%;margin:0 auto;");
        myMenu.setAttribute("style", "text-align: right");

        MyOKbutton.innerHTML = "OK";
        MyOKbutton.value = currentVoice;
        MyCancelbutton.innerHTML = "Cancel";
        MyCancelbutton.value = "cancel";

        mySpeed.innerText = speechRate;

        myInput.type = "range";
        myInput.min = "50";
        myInput.max = "200";
        myInput.value = speechRate * 100; /* current value */
        myInput.step = "10";

        Mydialog.appendChild(form);
        form.appendChild(Mylabel);
        form.appendChild(para);
        form.appendChild(selectList);
        form.appendChild(para.cloneNode());

        form.appendChild(myInput);
        form.appendChild(mySpeed);

        myMenu.appendChild(MyOKbutton);
        myMenu.appendChild(document.createTextNode(" "));
        myMenu.appendChild(MyCancelbutton);
        form.appendChild(myMenu);
        node.appendChild(Mydialog);

        myInput.addEventListener("input", function () {
          mySpeed.innerHTML = this.value / 100;
        });

        selectList.addEventListener("change", function onSelect(e) {
          MyOKbutton.value = selectList.value;
        });

        Mydialog.addEventListener("close", function onClose() {
          dialogIsOpen = false;
          if (Mydialog.returnValue != "cancel") {
            /* clear all variables and update the page data */

            speechRate = mySpeed.innerHTML;
            if (Mydialog.returnValue !== "") {
              currentVoice = Mydialog.returnValue;
              voiceName = regexEscape(voices[Mydialog.returnValue].name);
            }
            //message.voice = voices[Mydialog.returnValue];
            savePresets();

            /* Mydialog.remove();
      removeMyHighlight();
      MySettingsbutton.remove();
      alldescendants = [];
      clickorendHighlightReset();
      mapIndexForHighlight();*/
          }
        });

        for (var i = 0; i < voices.length; i++) {
          currentVoice = selectVoice(voiceName, 0);

          var option = document.createElement("option");
          option.setAttribute("value", i);
          option.text = voices[i].name;
          selectList.appendChild(option);

          if (i == currentVoice) {
            option.selected = "true";
          }
        }
      }

      function IsLink(curNode) {
        while (curNode) {
          if (
            (curNode.tagName && "textarea" === curNode.tagName.toLowerCase()) ||
            (curNode.tagName && "button" === curNode.tagName.toLowerCase()) ||
            (curNode.tagName && "input" === curNode.tagName.toLowerCase()) ||
            (curNode.tagName && curNode.tagName.toLowerCase() == "a") ||
            (curNode.nodeType < 3 && curNode.hasAttribute("onclick"))
          ) {
            return true;
          } else {
            if (curNode) curNode = curNode.parentNode;
          }
        }
        return false;
      }

      function sendMessageToBackground(message) {
        /*try {
            chrome.runtime.sendMessage({ greeting: message });
          } catch (Ex) {
            console.log(Ex);
          }*/
      }

      /*var Roody = eruda.init();*/
      var addonisEnabled = false;
      document.addEventListener("click", clickHandler);

      function clickHandler(evnt) {
        //loadDelayedPresets();

        if (canClick == false || evnt.target == speechCircle) {
          return;
        }

        if (Math.abs(evnt.pageX - xloc) > 10 || Math.abs(evnt.pageY - yloc) > 10) {
          return;
        }
        if (isPaused == 0) {
          try {
            /*pauseForAfew();*/
            if (canceled == false) {
              sendClick(evnt);
            } else {
              sendClick(evnt);
            }
          } catch (Ex) {
            console.log(Ex);
          }
        }
      }

      var xloc, yloc;
      document.addEventListener("mousedown", (e) => {
        xloc = e.pageX;
        yloc = e.pageY;
      });

      function fillEventNodes(evnt) {
        allEventNodes = [];
        for (var i = 0; i < evnt.path[0].childNodes.length; i++) {
          allEventNodes.push(evnt.path[0].childNodes[i]);
        }
        for (var i = 0; i < evnt.target.childNodes.length; i++) {
          recurseAndAdd(evnt.target.childNodes[i], allEventNodes);
        }
      }

      function findTrigger(searchThrough = alldescendants) {
        var trigger = -1;

        if (searchThrough == null || !alldescendantsToSpanid) {
          return trigger;
        }

        loop1: for (var i = 0, max = searchThrough.length; i < max; i++) {
          for (var j = 0, maxyy = allEventNodes.length; j < maxyy; j++) {
            if (allEventNodes[j] === searchThrough[i] && alldescendantsToSpanid[i] != -1) {
              alldescendantsToSpanid[i] && (trigger = alldescendantsToSpanid[i]);
              !alldescendantsToSpanid[i] && (trigger = i);
              break loop1;
            }
          }
        }

        return trigger;
      }

      function shouldDeepScan() {
        if (_ultrafast == true && findTrigger(_ultra_descendants) != -1) {
          _ultra_index = 0;
          _ultra_xLengthRead = 0;
          // resetting the buffer on deepScan because
          //we start from 0 and rescan all
          //without map Nodes From Root Val
          _ultra_xLengthBuffer = 0;
          _ultra_lastRect = null;
          return false;
        }
        return true;
      }

      function hasSelection() {
        /* if the selector was dragged return false */
        if (wasDragged == true) {
          return false;
        }

        selection = window.getSelection();
        if (
          (selection && selection.rangeCount >= 0 && selection.anchorNode != null) ||
          (selection.focusNode != null && selection.anchorNode != null && selection.getRangeAt(0).startOffset == 0 && selection.getRangeAt(0).endOffset == 0)
        ) {
          if (selection.anchorNode != null && selection.getRangeAt(0).startOffset == 0 && selection.getRangeAt(0).endOffset == 0) {
            /* prevents it from starting from 0th location if it's paused */
            if (!myHilightSpan) {
              return true;
            }
          }

          var range = selection.getRangeAt(0);
          if (Math.abs(range.endOffset - range.startOffset) > 0) {
            return true;
          }
        }

        if (selection.anchorOffset != 0) {
          return true;
        }

        return false;
      }

      /*gets the index of the selected word*/
      function getWordClicked() {
        selection = window.getSelection();
        if ((selection && selection.rangeCount >= 0) || (selection.anchorNode != null && selection.getRangeAt(0).startOffset == 0 && selection.getRangeAt(0).endOffset == 0)) {
          var range = selection.getRangeAt(0);
          var node = selection.anchorNode;
          var startOffset = range.startOffset;

          allEventNodes = [];
          allEventNodes.push(node);
          allEventNodes.push(selection.focusNode);

          if ((doc != null && isHilightSpan(node)) || isHilightSpan(selection.focusNode)) {
            allEventNodes = [];
            allEventNodes.push(doc.firstChild);
            startOffset = 0;
          }

          /*adjust for the original string if it has multiple repeating spaces*/
          if (node && node.textContent && node.textContent.length > 0) {
            var totalStr = node.textContent.substring(0, startOffset);
            var L1 = totalStr.length;
            totalStr = callReplace(totalStr);
            var L2 = totalStr.length;
            startOffset = startOffset - (L1 - L2);
          }

          var word_regexp = /\s+/;
          trigger = findTrigger();
          if (trigger >= 0 && startOffset > 0) {
            while (trigger >= 0 && startOffset > 0 && !totalStr.charAt(startOffset).match(word_regexp)) {
              startOffset--;
            }

            //console.log(startOffset + " " + totalStr + " |" + totalStr.charAt(startOffset) + "|" + node.textContent + " length dif " + lengthDifference);
            if (totalStr.charAt(startOffset).match(word_regexp)) {
              startOffset++;
            }

            //used to subtract one if there are spaces or new lines before the start of the first character, even though
            //html doesn't display it on screen.
            //var lengthDifference = node.textContent.length - node.textContent.trimStart().length;
            //if (lengthDifference > 0) {
            //startOffset--;
            //}
          }

          richCaretIndex = spanxLocations[trigger] + startOffset;
          if (readMultipleNodes && nodesToWords) {
            richCaretIndex = nodesToWords[richCaretIndex];
          }

          return true;
        }

        return false;
      }

      const pointInRect = (x1, y1, x2, y2, x, y) => x > x1 && x < x2 && y > y1 && y < y2;

      function sendClick(evnt, curentTarget = null, attempts = 0) {
        if (attempts == 0) {
          if (evnt != null) {
            /*if it's a link, don't read it*/
            if (IsLink(evnt.target)) {
              return;
            }
            fillEventNodes(evnt);
          } else if (curentTarget != null) {
            allEventNodes = [];
            if (curentTarget.length) {
              for (var i = 0; i < curentTarget.length; i++) {
                recurseAndAdd(curentTarget[i], allEventNodes);
              }
            } else {
              for (var i = 0; i < curentTarget.childNodes.length; i++) {
                recurseAndAdd(curentTarget.childNodes[i], allEventNodes);
              }
            }

            for (var i = 0; i < allEventNodes.length; i++) {
              if (allEventNodes[i] && allEventNodes[i].parentNode) {
                if (px == null && py == null) {
                  curentTarget = allEventNodes[0];
                }
                domRect = allEventNodes[i].parentNode.getBoundingClientRect();
                if (pointInRect(domRect.left, domRect.top, domRect.right, domRect.bottom, px, py)) {
                  var tmp = allEventNodes[i];
                  allEventNodes = [];
                  allEventNodes.push(tmp);
                  curentTarget = tmp;
                  break;
                }
              }
            }
          }
        }

        if (hasSelection()) {
          getWordClicked();
        }

        trigger = findTrigger();
        if (curentTarget == "bookmark" && _ultra_descendants && _ultra_descendants[0] != null) {
          trigger = 0;
        }
        if (curentTarget != "bookmark") {
          bookmarkString = "";
        }

        if (!curentTarget && evnt != null) {
          curentTarget = evnt.target;
        }

        var match = isHilightSpan(curentTarget);

        if (dialogIsOpen == false && trigger == -1 && canceled == true && match == false) {
          if (attempts == 0 && (curentTarget != null || x == null)) {
            _curentTarget = curentTarget;
            Array.isArray(curentTarget) && (_curentTarget = curentTarget[0]);
            if (shouldDeepScan()) {
              updateIndexes(10, true); /* double tap to rescan*/
            } else {
              mapIndexForHighlight();
            }
            sendClick(evnt, curentTarget, 1);
            return;
          }
        }

        if ((evnt && curentTarget.id.indexOf("ttsh") >= 0) || match) {
          togglePlayButton();
        } else {
          if (canceled == true && !evnt && hasSelection() && getWordClicked()) {
            togglePlayButton();
            return;
          }
          if (canceled == true && trigger >= 0) {
            window.speechSynthesis.cancel();
            clickorendHighlightReset();
            richCaretIndex = spanxLocations[trigger];
            if (readMultipleNodes && nodesToWords) {
              richCaretIndex = nodesToWords[richCaretIndex];
            }
            readText();
          } else if (canceled == false) {
            canceled = true;
            unHilight();
            window.speechSynthesis.cancel();
            sendMessageToBackground("paused");
            clickorendHighlightReset();
          }
          window.getSelection().removeAllRanges(); /* here to clear the selection on pause*/
        }
      }

      function isHilightSpan(curentTarget) {
        if (myHilightSpan && curentTarget && curentTarget.parentNode) {
          if (curentTarget === myHilightSpan || curentTarget.parentNode === myHilightSpan || (curentTarget.parentNode && curentTarget.parentNode.parentNode === myHilightSpan)) {
            return true;
          }
        }

        return false;
      }

      function togglePlayButton() {
        window.getSelection().removeAllRanges(); /* here to clear the selection on pause*/
        if (canceled == true) {
          if (docsFirstChild && x == null && _ultrafast && _ultra_index != 0) {
            playAfterOptionsUpdate();
          } else {
            readText();
          }
        } else {
          pause();
        }
      }

      var extentionIsOn = false;

      function logKey(e) {
        if (e.code == "Space" && (e.target == document.body || e.target == document.body.parentNode)) {
          if (canceled == false) {
            e.preventDefault();
            togglePlayButton();
          } else {
            if (extentionIsOn) {
              if (hasSelection() || lastoffset != 0 || autoPlayThisSite(false)) {
                e.preventDefault();
              }
              //e.preventDefault();
            }

            /* start playback from object */
            if (hasSelection()) {
              sendClick(null, window.getSelection().anchorNode.parentNode);
            } else if ((ap = autoPlayThisSite(false))) {
              sendClick(null, autoPlayThisSite());
            } else {
              togglePlayButton();
            }
          }
        }
      }

      // press space bar to read from className location.
      function autoPlayThisSite(t = true) {
        if (pressedOnBookmarkOrPlay == false && window.location.href.match(/royalroad\.com/gi)) {
          if (t) {
            pressedOnBookmarkOrPlay = true;
          } else {
            return document.getElementsByClassName("chapter-inner chapter-content")[0] != null;
          }
          return [document.getElementsByClassName("chapter-inner chapter-content")[0]];
        }
        return false;
      }


      var dialogIsOpen = false;
      function openDialog(e) {
        e.preventDefault();
        if (Mydialog != null) {
          dialogIsOpen = true;
          e.target.blur();
          Mydialog.showModal();
        }
      }

      function savePresets() {
        chrome.storage.sync.set({
          voiceIndex: currentVoice,
          voiceName: voiceName,
          voiceSeed: speechRate * 100,
        });
      }

      function update() {
        if (doc != null) {
          removeMyHighlight();
        }
        alldescendants = [];
        nodesToWords = [];
        wordsToNodes = [];

        mapIndexForHighlight();

        /*console.log( x + " mapped this" );*/
        if (!hasSelection() && canceled == false) {
          highlight();
        } else if (!hasSelection() && lastDoc != null) {
          highlight(false);
          /*addDialogToNode(lastDoc);*/
        }
      }

      var updating = 0;
      function updateIndexes(ms = 2000, shouldUpdate = false) {
        update();
      }

      function showElement(element) {
        /*console.log( "show element ");*/
        if (element) {
          element.style.visibility = "visible";
          document.body.append(element);
          dragElement(speechCircle);
        }
      }

      function hideElement(element) {
        /*console.log( "hide element ");*/
        if (element) {
          element.style.visibility = "hidden";
          if (document.body.contains(element)) {
            document.body.removeChild(element);
          }
        }
      }

      function inIframe() {
        try {
          return window.self !== window.top;
        } catch (e) {
          return true;
        }
      }

      function loadDelayedPresets() {
        var delay = 500;
        if (inIframe()) {
          delay = 3000;
        }

        var interval = setInterval(function () {
          if (ranAtLeastOnce == false) {
            firstCallFromLoaded = true;
            loadPresets();
          }
          clearInterval(interval);
        }, delay);
      }

      var speechCircle;
      var replaceLen = null;
      var firstCallFromLoaded = false;
      function loadPresets() {
        // first loadPresets call should be from local functions to make sure the page is loaded
        // isntead of from a message event from background.js
        if (firstCallFromLoaded == false) {
          return;
        }
        ranAtLeastOnce = true;
        var replace = "";
        items = {
          voiceIndex: "10",
          voiceName: "Microsoft Aria",
          voiceSeed: 100,
          replaceStr: "",
          divhilight: false,
          yhighlightonly: true,
          clickValue: false,
          slideValue: false,
          dragsizeValue: "30",
          continousValue: true,
          spacebarValue: false,
          autoscrollValue: true,
        };

        var tmpRep = localStorage.getItem("replaceStr");
        if (tmpRep) {
          items.replaceStr = tmpRep;
        }

        canClick = items.clickValue;
        hasspeechCircle = items.slideValue;

        if (readMultipleNodes != items.continousValue) {
          if (nodesToWords) {
            removeMultipleNodeHilights();
          }

          nodesToWords = [];
          wordsToNodes = [];
          alldescendants = [];
          if (x && x.length > 0 && canceled == false) {
            x = "";
            pause();
          }
          removeMyHighlight();
          clickorendHighlightReset();
        }
        readMultipleNodes = items.continousValue;
        autoscroll = items.autoscrollValue;

        if (speechCircle && hasspeechCircle) {
          speechCircle.style.visibility = "visible";
          speechCircle.style.lineHeight = items.dragsizeValue + "px";
          speechCircle.style.height = items.dragsizeValue + "px";
          speechCircle.style.width = items.dragsizeValue + "px";
          if (!inIframe() || (inIframe() && document.body.children.length > 1)) {
            document.body.appendChild(speechCircle);
          }
        }
        if (speechCircle && loaded) {
          !hasspeechCircle && hideElement(speechCircle);
          hasspeechCircle && checkIfOn();
        }

        if (!loaded && items.slideValue == true) {
          loaded = true;

          speechCircle = document.createElement("div");

          if (inIframe()) {
            circletop = "10px";
            circlebottom = null;
            circleleft = null;
            circleright = "10px";
            speechCircle.style && (speechCircle.style.opacity = "0.1");
          } else {
            speechCircle.style && (speechCircle.style.opacity = "0.5");
          }
          if (speechCircle.style) {
            speechCircle.innerText = " ";
            speechCircle.style.position = "fixed";
            speechCircle.style.zIndex = "1000000";
            speechCircle.style.backgroundColor = "#2196F3";
            speechCircle.style.textAlign = "center";
            speechCircle.style.border = "1px solid #d3d3d3";
            speechCircle.style.bottom = circlebottom;
            speechCircle.style.right = circleright;
            speechCircle.style.left = circleleft;
            speechCircle.style.top = circletop;
            speechCircle.style.lineHeight = items.dragsizeValue + "px";
            speechCircle.style.height = items.dragsizeValue + "px";
            speechCircle.style.width = items.dragsizeValue + "px";
            /*speechCircle.style.borderRadius = "25%"*/
            speechCircle.style.dsplay = "inline-block";
            speechCircle.style.cursor = "default";
            speechCircle.style.setProperty("border-radius", "25%", "important");
            speechCircle.style.setProperty("padding", "initial");
          }

          speechCircle.id = "mytexttospeechdiv";

          if (!inIframe() || (inIframe() && document.body.children.length > 1)) {
            document.body.appendChild(speechCircle);
          }

          getBookmarkFromStorage(window.location.href);
          dragElement(speechCircle);
          checkIfOn();
        }

        if (!inIframe()) {
          if (items.spacebarValue) {
            document.addEventListener("keydown", logKey);
          } else {
            document.removeEventListener("keydown", logKey);
          }
        }

        
        //voiceName = items.voiceName;
        //speechRate = items.voiceSeed / 100;

        speechRate = localStorage.getItem("speed") / 100;

        var button = document.getElementById("btn");
        button.disabled = false;

        replace = items.replaceStr;
        NotOnboundary = items.divhilight;
        if (isEdge) {
          yellowHighlightOnly = items.yhighlightonly;
        }
        if (!isEdge) {
          NotOnboundary = true;
        }

        /* update indexes if replace values have changed */
        if (replaceLen == null || replaceLen != replace.length) {
          replaceDictionary = {
            "[\u0300-\u036f]": "",
            "[\u201C\u201D]": '"',
          };
          eraseDictionary = {};

          /*replace = replace.replace(/=>/g, "\n");*/
          var lines = replace.split(/\r?\n/);
          for (var i = 0; i < lines.length; i++) {
            var eachLine = lines[i].split("=>");
            if (eachLine && eachLine[0] && eachLine.length > 1) {
              if (eachLine.length > 2) {
                if (eachLine[0].match(/erase/gi)) {
                  addToEraseDictionary(eachLine[1], eachLine[2]);
                } else {
                  let key = eachLine[1];
                  let value = eachLine[2];
                  replaceDictionary[key] = fx(value);
                  //AddSpaceAlternativeDict( key, value );
                }
              } else {
                let key = regexEscape(eachLine[0]);
                let value = eachLine[1];
                replaceDictionary[key] = fx(value);
                //AddSpaceAlternativeDict( key, value );
              }
            }
          }

          replaceDictionary["\\s+"] = " ";

          //reset everything if data changed
          //reset Alldescendants so next time speech has to be rescanned. If I'm going to leave an option for
          //non continuous reading I'll have to add to the rescan logic on sendclick.
          alldescendants = [];
          _ultra_Xstr = "";
          x = null;
          if (!canceled && _ultra_index != 0 && docsFirstChild) {
            playAfterOptionsUpdate();
          }

          //updateIndexes(10, true);
          /*console.log( "dictonary updated");*/
        }
        replaceLen = replace.length;
      }

      function AddSpaceAlternativeDict(key, value) {
        if (readMultipleNodes && key.match(/ /g)) {
          key = key.replace(/ /g, spaceAlternative);
          replaceDictionary[key] = fx(value);
        }
      }

      function playAfterOptionsUpdate() {
        let currentTarget = [];
        let _curentTarget = null;
        _curentTarget = docsFirstChild.parentNode.parentNode;
        currentTarget.push(_curentTarget);
        pause();
        updateIndexes(10, true);
        sendClick(null, currentTarget);
      }

      function addToEraseDictionary(wordToErase, parameters) {
        eraseDictionary[wordToErase] = parameters;
      }

      const filler = (size, chr = " ") => Array(size).fill(chr).join("");
      function eraseR(key, value, OriginalStr) {
        /*tmpStr = replaceWord(tmpStr, key, value, false);*/
        var mykey = key;
        const reg = new RegExp(mykey, value);
        var result;

        while ((result = reg.exec(OriginalStr)) !== null) {
          var my_start = result.index;
          var my_end = my_start + result[0].length;

          var firstHalf = OriginalStr.substring(0, my_start);

          //var erased = filler(my_end - my_start, " ");
          str = OriginalStr.substring(my_start, my_end);
          regex = new RegExp(/[^\n]/, "gi");
          erased = str.replace(regex, " ");

          var lastHalf = OriginalStr.substring(my_end);

          OriginalStr = firstHalf + erased + lastHalf;
        }
        return OriginalStr;
      }

      function eraseWords(str) {
        for (const [key, value] of Object.entries(eraseDictionary)) {
          str = eraseR(key, value, str);
        }
        return str;
      }

      

      function fx(str) {
        if (readMultipleNodes) {
          if (str == "  ") {
            return " ";
          } else {
            return str.replace(/\s+/g, spaceAlternative) + NullSpaceAlternative;
          }
        }
        return str;
      }

      function checkIfOn() {
        /*console.log("check if on");*/
        if (speechCircle) {
          hideElement(speechCircle);
        }
      }

      function justLoaded() {
        loadDelayedPresets();
      }

      justLoaded();

      /* TO DO: inject this into the page */
      /*dragElement(document.getElementById("mydiv"));*/

      var wasDragged = false;
      function updateDragged(bln) {
        wasDragged = bln;
      }

      function dragElement(elmnt) {
        function is_touch_device() {
          try {
            document.createEvent("TouchEvent");
            return true;
          } catch (e) {
            return false;
          }
        }
        var pos1 = 0,
          pos2 = 0,
          pos3 = 0,
          pos4 = 0;
        var currentTarget = [];
        var clickXpos;
        var clickYpos;
        var startPosX, startPosY;
        var touch_capable = is_touch_device();
        var wasPressed = false;
        if (touch_capable) {
          elmnt.ontouchstart = dragMouseDown;
        } else {
          elmnt.onmousedown = dragMouseDown;
        }

        function dragMouseDown(e) {
          wasPressed = true;
          elmnt.style.transition = null;
          if (touch_capable) {
            e.preventDefault();
            var touch = e.touches[0];

            pos3 = touch.pageX;
            pos4 = touch.pageY;
            startPosX = touch.pageX;
            startPosY = touch.pageY;

            document.ontouchend = closeDragElement;
            // call a function whenever the cursor moves:
            document.ontouchmove = elementDrag;
          } else {
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            startPosX = e.clientX; /*elmnt.offsetTop;*/
            startPosY = e.clientY; /*elmnt.offsetLeft;*/

            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
          }
        }

        function elementDrag(e) {
          if (touch_capable) {
            var touch = e.touches[0];
            try {
              e.preventDefault();
            } catch (Ex) {}

            pos1 = pos3 - touch.pageX;
            pos2 = pos4 - touch.pageY;
            pos3 = touch.pageX;
            pos4 = touch.pageY;
          } else {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
          }

          if (elmnt.style.left && elmnt.style.top) {
            clickXpos = parseInt(elmnt.style.left) - 3;
            clickYpos = parseInt(elmnt.style.top);
          }

          // set the element's new position:
          elmnt.style.top = elmnt.offsetTop - pos2 + "px";
          elmnt.style.left = elmnt.offsetLeft - pos1 + "px";
        }

        function closeDragElement() {
          /* stop moving when mouse button is released:*/
          if (touch_capable) {
            document.ontouchend = null;
            document.ontouchmove = null;
          } else {
            document.onmouseup = null;
            document.onmousemove = null;
          }

          elmnt.style.bottom = circlebottom;
          elmnt.style.right = circleright;
          elmnt.style.left = circleleft;
          elmnt.style.top = circletop;
          /*}*/

          if (clickXpos == undefined || clickYpos == undefined) {
            clickXpos = pos3;
            clickYpos = pos4;
          }

          temporarilyHideSpeechCircle();

          if ((hasSelection() && wasDragged(startPosX, pos3, startPosY, pos4) == false) || (canceled == false && wasDragged(startPosX, pos3, startPosY, pos4) == false)) {
            clickXpos = pos3;
            clickYpos = pos4;
            trigger(true);
          } else if (clickXpos && clickYpos && wasPressed) {
            wasPressed = false;
            currentTarget = [];
            var elms = document.elementFromPoint(clickXpos, clickYpos);
            if (elms) {
              currentTarget.push(elms);
            }
            elms = document.elementsFromPoint(clickXpos, clickYpos);
            if (elms && elms.length > 1) {
              currentTarget.push(document.elementsFromPoint(clickXpos, clickYpos)[1]);
            }

            if (wasDragged(startPosX, pos3, startPosY, pos4) == false) {
              //code for resuming from bookmark, bookmarkString should get reset to "" right after first attempt.
              if (_ultrafast && pressedOnBookmarkOrPlay == false && trimmer(bookmarkString).length > 0) {
                pressedOnBookmarkOrPlay = true;
                currentTarget = [];
                currentTarget.push("bookmark");

                trigger(false);
                return;
              }

              trigger(true);
              return;
            }

            px = clickXpos;
            py = clickYpos;
            if (currentTarget && currentTarget.length > 0) {
              trigger();
            }
          }
        }

        function wasDragged(x1, x2, y1, y2) {
          if (x1 && x2 && y1 && y2 && Math.abs(x1 - x2) < 10 && Math.abs(y1 - y2) < 10) {
            updateDragged(false);
            return false;
          }
          updateDragged(true);
          return true;
        }

        function trigger(toggle = false) {
          if (canceled == false) {
            if (toggle) {
              togglePlayButton();
            } else {
              sendClick(null, currentTarget);
            }
          } else {
            if (toggle) {
              if (hasSelection()) {
                sendClick(null, window.getSelection().anchorNode.parentNode);
              } else {
                if (x == null) {
                  sendMessageToBackground("play-selection");
                }
                togglePlayButton();
              }
            } else {
              sendClick(null, currentTarget);
            }
          }
        }

        function temporarilyHideSpeechCircle() {
          if (
            (circletop == "10px" || x == null) &&
            hasSelection() == false &&
            wasDragged(startPosX, pos3, startPosY, pos4) == false &&
            canceled == true &&
            (trimmer(bookmarkString).length == 0 || pressedOnBookmarkOrPlay == true)
          ) {
            //hideElement(speechCircle);
            moveCircle(null, "100px");
            unhideAfterDelay();
          }
        }

        function unhideAfterDelay() {
          var interval = setInterval(function () {
            //showElement(speechCircle);
            moveCircle(null, "10px");
            clearInterval(interval);
          }, 2000);
        }

        function moveCircle(left, right) {
          if (speechCircle && speechCircle.style) {
            speechCircle.style.transition = "all .5s ease-in-out";
            speechCircle.style.left = left;
            speechCircle.style.right = right;
          }
        }
        /*function noStyle(elmnt){

    document.body.appendChild(elmnt);
    elmnt.outerHTML = '<div id="mytexttospeechdiv" style="opacity: 0.5; position: fixed; z-index: 19001; background-color: rgb(27, 73, 228); text-align: center; border: 1px solid rgb(211, 211, 211); bottom: 10px; right: 10px; line-height: 30px; height: 30px; width: 30px; cursor: default; border-radius: 25% !important; padding: initial;"> </div>'
    document.addEventListener("mousedown", (e) => {
      if( e.target.id == elmnt.id ){
        e.preventDefault();
        trigger( true );
      }
    });
  }*/
      }

      /////////////////////////// end of new code

      $("input").on("change", function () {
        console.log($(this).attr("id"), $(this).val());
        message[$(this).attr("id")] = $(this).val();
      });

      function saveText() {
        var text = document.getElementById("text");
        localStorage.setItem("text", text.innerHTML.substring(0, 300000).trim());
        localStorage.setItem("voiceName", voiceName);
        saveReplace();
      }

      $(function () {
        $("#btn2").on("click", function () {
          //alert("Hello");
          //window.alert(event.charIndex);

          var button = document.getElementById("btn");
          button.disabled = false;

          pause();
          removeMultipleNodeHilights();

          //cleanup();
          //beforelastoffset=0;
          //lastoffset=0;
          //offset=2;
        });
      });

      /*document.getElementById("flex").addEventListener("click", function (e) {
          window.getSelection().removeAllRanges();
          e.stopPropagation();
        });

        document.getElementById("flex").addEventListener("mousedown", function (e) {
          var button = document.getElementById("btn");
          if (button == e.path[0]) {
            //console.log( "button" );
          } else {
            window.getSelection().removeAllRanges();
            e.stopPropagation();
          }
        });*/

      $(function () {
        document.getElementById("text").addEventListener(
          "input",
          function () {
            alldescendants = [];
            x = null;
          },
          false
        );

        document.getElementById("text").addEventListener(
          "click",
          function () {
            var myDropdown = document.getElementById("myDropdown");
            if (myDropdown.classList.contains('show')) {
              myDropdown.classList.remove('show');
              saveReplace();
            }
          },
          false
        );


        

        $("#btn").on("click", function () {
          removeMultipleNodeHilights();
          saveText(); // save text after cleanup

          var button = document.getElementById("btn");
          button.disabled = true;

          try {
            var selection = window.getSelection().anchorNode;
            if (doesTopParentMatch(selection, "flex")) {
              window.getSelection().removeAllRanges();
            }
          } catch (Ex) {}

          try {
            currentTarget = [];
            currentTarget.push(window.getSelection().anchorNode);
            var text = document.getElementById("text");
            if (text != window.getSelection().anchorNode.parentNode) {
              //currentTarget.push(window.getSelection().anchorNode.parentNode);
            }

            //console.log( currentTarget );

            sendClick(null, currentTarget);
          } catch (Ex) {
            if (x == "" || x == null) {
              var text = document.getElementById("text");
              sendClick(null, text);
            } else {
              togglePlayButton();
            }
          }
        });
      });

  
        // Hack around voices bug
        var intervalZ = setInterval(function () {
          voices = speechSynthesis.getVoices();
          if (voices.length) clearInterval(intervalZ);
          else return;

          let myPersonalPref = 0;

          for (var i = 0; i < voices.length; i++) {
            $("select").append('<option value="' + i + '">' + voices[i].name + "</option>");
            if (voices[i].name == voiceName) {
              myPersonalPref = i;
            }
          }

          $("#voice").val(myPersonalPref).trigger("change");

           document.getElementById("voice").addEventListener("change",voiceChanged);

        function voiceChanged(){

          message.voice = voices[$(this).val()];
          if (voices[$(this).val()] != undefined) {
            voiceName = voices[$(this).val()].name; 
            currentVoice = items.voiceIndex;
          }
        }
          
        }, 100);

       

      var running = false;
      function myFunction() {
        document.getElementById("myDropdown").classList.toggle("show");
        if (running == false) {
          //startIt();
          running = true;
        } else {
          //stopIt();
          running = false;
          saveReplace();
        }
      }

      function saveReplace() {
        var replace = document.getElementById("replace");
        localStorage.setItem("replaceStr", replace.value.substring(0, 50000).trim());
        loadPresets();
      }
    </script>
    <title>Read it</title>
  </head>

  <body style="background-color: powderblue">
    <div id="hello">
      <div style="flex: 0 1 auto" id="flex">
        <button id="btn" class="button button2">Read</button>
        <button id="btn2" class="button button2">Stop</button>

        <button class="dropbtn" onclick="myFunction()">Options</button>
        <div class="dropdown-content" style="position: absolute; left: 224px" id="myDropdown">
          <div id="body" style="padding: 5px; height: 500; visibility: visible">
            <canvas id="c" class="canvyy" style="width: 500px; height: 480px; position: fixed; z-index: -1"></canvas>

            <div style="width: 500px; height: 480px">
              <div style="padding: 5px; background-color: rgba(240, 236, 233, 0.87)">
                Current Voice:
                <select id="voice"></select>
                <br />
                <span style="margin-right: 35px">Speed:</span>
                <input type="range" id="speed" name="volume" step="10" min="50" max="200" />
                <label type="span" id="mySpeedValue"></label>
              </div>
              <div>
                <p></p>
                <textarea name="text" id="replace" style="height:383px; resize: none; background-color: rgba(255, 255, 255, 0.87); width: 98.5%"></textarea>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div contenteditable="true" id="text" name="text">Text goes here.</div>
    </div>

    <script>
      var slider = document.getElementById("speed");
      var output = document.getElementById("mySpeedValue");
      output.innerHTML = slider.value / 100;

      slider.oninput = function () {
        output.innerHTML = this.value / 100;
        localStorage.setItem("speed", this.value);
      };

      document.getElementById("replace").placeholder = "Replace spoken words.\n\nExample:\nJan.=>January\n\nOr with RegEx\nRegEx=>Jan\\.=>January";

      var button = document.getElementById("btn");
      button.disabled = true;

      (function () {
        // loading data from local storage
        var slider = document.getElementById("speed");
        var output = document.getElementById("mySpeedValue");
        slider.value = localStorage.getItem("speed");
        speechRate = slider.value / 100;
        //console.log(speechRate);
        voiceName = localStorage.getItem("voiceName");
        output.innerHTML = slider.value / 100;

        var text = document.getElementById("text");
        var loaded_text = localStorage.getItem("text");
        if (loaded_text) {
          text.innerHTML = loaded_text;
        }

        var replace = document.getElementById("replace");
        var replaceStr = localStorage.getItem("replaceStr");
        if (replaceStr) {
          replace.value = replaceStr;
        }
      })();

      var c = document.getElementById("c");
      var ctx = c.getContext("2d");

      c.height = 1080 * 0.56; //window.innerHeight;
      c.width = 1920 * 0.56; //window.innerWidth;
      var chinese = "ç°ç±ç²ç³ç´çµç¶ç·ç¸ç¹çºç»ç¼ç½ç¾ç¿çççççççççççççççççç";
      chinese = chinese.split("");
      var font_size = 12;
      var columns = c.width / font_size;
      var drops = [];
      var erase = [];
      var redLine = -1;
      for (var x = 0; x < columns; x++) {
        drops[x] = c.height;
        erase[x] = c.height;
      }
      function draw() {
        ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.fillStyle = "#0F0";
        ctx.font = font_size + "px arial";
        for (var i = 0; i < drops.length; i++) {
          if (checkDrops(drops[i])) {
            drops[i] = 0;
          }
          if (drops[i] < c.height && checkDrops(erase[i]) && drops[i] > 20) {
            erase[i] = 0;
          }

          var text = chinese[Math.floor(Math.random() * chinese.length)];
          ctx.fillStyle = "#0000AB";
          ctx.fillText(text, i * font_size, drops[i] * font_size);
          drops[i]++;

          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(i * font_size, erase[i] * font_size, font_size, font_size);
          erase[i]++;
        }
      }

      function checkDrops(e) {
        return e * font_size > c.height && Math.random() > 0.975;
      }

      var interV = 0;
      function startIt() {
        if (interV == 0) {
          interV = setInterval(draw, 66);
        }
      }

      function stopIt() {
        if (interV != 0) {
          clearInterval(interV);
          interV = 0;
        }
      }

      ctx.fillStyle = "rgba(255, 255, 255, 1.0)";
      ctx.fillRect(0, 0, c.width, c.height);
    </script>
  </body>
</html>
